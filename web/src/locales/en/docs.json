{
  "sidebar.gettingStarted": "Getting Started",
  "sidebar.overview": "Overview",
  "sidebar.quickstart": "Quickstart",
  "sidebar.integrations": "Integrations",
  "sidebar.surfaces": "Surfaces",
  "sidebar.cli": "CLI",
  "sidebar.vscodeExtension": "VS Code Extension",
  "sidebar.discordBot": "Discord Bot",
  "sidebar.spectaclesAR": "Spectacles AR",
  "sidebar.piDisplays": "Pi Displays",
  "sidebar.reference": "Reference",
  "sidebar.architecture": "Architecture",
  "sidebar.selfHosting": "Self-Hosting",
  "sidebar.resources": "Resources",
  "sidebar.llmDocs": "LLM Docs (llms.txt)",
  "sidebar.github": "GitHub",
  "sidebar.discord": "Discord",
  "overview.title": "Eywa Documentation",
  "overview.lead": "Eywa is an observability and coordination layer for human + AI teams. Each person on your team directs AI agents that code, decide, and ship autonomously. Eywa makes all of that work visible so the humans stay aligned.",
  "overview.whatIsEywa": "What is Eywa?",
  "overview.whatIsEywaDesc": "Eywa is an MCP server that gives your team shared visibility across every AI agent session. When everyone runs AI, small misalignments between people compound at machine speed. Eywa gives one shared view of what all agents are building so you know what to sync on. It works with any agent that supports the Model Context Protocol: Claude Code, Cursor, Windsurf, Gemini CLI, Codex, Cline, and more.",
  "overview.coreFeatures": "Core Features",
  "overview.destinationProgress": "Destination & Progress",
  "overview.destinationProgressDesc": "Set a target state for your team, define milestones, and track completion as agents ship. Agents report progress with percentage and status. The destination is visible on every surface: web dashboard, VS Code sidebar, Discord, and MCP auto-context.",
  "overview.liveAgentMap": "Live Agent Map",
  "overview.liveAgentMapDesc": "See what every agent across your team is working on in real time. Each agent's status, task, systems touched, and progress are visible on the HubView dashboard. Active agents are highlighted, with operation metadata (system, action, scope, outcome) for full observability.",
  "overview.contextInjection": "Context Injection",
  "overview.contextInjectionDesc": "Push decisions or corrections into any agent mid-session. Agents see injections on their next tool call through automatic piggyback delivery. Supports normal, high, and urgent priority levels.",
  "overview.teamKnowledge": "Team Knowledge",
  "overview.teamKnowledgeDesc": "Persistent memory that survives across all sessions. Store architecture decisions, API conventions, gotchas, and patterns with <code>eywa_learn</code>. Knowledge is searchable by tags and content, and surfaces in agent auto-context at session start.",
  "overview.timelineBranching": "Timeline & Branching",
  "overview.timelineBranchingDesc": "Git-like version control for agent work. Rewind to any point with <code>eywa_rewind</code>, fork alternate timelines with <code>eywa_fork</code>, cherry-pick moments across branches with <code>eywa_pick</code>, and merge back with <code>eywa_merge</code>. Bookmark important decisions for easy navigation.",
  "overview.globalInsights": "Global Insights Network",
  "overview.globalInsightsDesc": "Publish anonymized patterns from your room with <code>eywa_publish_insight</code>. Query cross-room intelligence with <code>eywa_query_network</code> so your agents learn from what worked in other teams. Lane recommendations suggest relevant insights based on your current task.",
  "overview.contextRecovery": "Context Recovery",
  "overview.contextRecoveryDesc": "Agents checkpoint their progress with <code>eywa_checkpoint</code> and send distress signals with <code>eywa_distress</code> when context runs low. New sessions auto-recover where the last one left off. Baton passing lets agents hand off work mid-session.",
  "overview.workClaiming": "Work Claiming",
  "overview.workClaimingDesc": "Agents declare what they're working on with <code>eywa_claim</code> to prevent duplicate effort. Active claims are visible in session snapshots and MCP instructions. Claims auto-release when sessions end.",
  "overview.geminiSteering": "Gemini Steering",
  "overview.geminiSteeringDesc": "Built-in Gemini chat panel with 6 tools for querying agent status, detecting patterns, analyzing distress signals, and steering the team. Proactively alerts on detected issues and agent distress.",
  "overview.interactionSurfaces": "Interaction Surfaces",
  "overview.interactionSurfacesDesc": "The same navigation model (destination, course, steering) works on every surface:",
  "overview.surfaceWeb": "Web Dashboard",
  "overview.surfaceWebDesc": "HubView with agent map, destination banner, Gemini chat, activity stream, and inject bar",
  "overview.surfaceVscode": "VS Code Extension",
  "overview.surfaceVscodeDesc": "Sidebar with agent avatars, activity feed, attention notifications, and agent detail panel next to terminals",
  "overview.surfaceDiscord": "Discord Bot",
  "overview.surfaceDiscordDesc": "15 slash commands for team steering: <code>/destination</code>, <code>/course</code>, <code>/status</code>, <code>/inject</code>, and more",
  "overview.surfaceCli": "CLI",
  "overview.surfaceCliDesc": "<code>npx eywa-ai init</code> for zero-auth room setup, plus status, inject, and log commands",
  "overview.surfaceSpectacles": "Spectacles AR",
  "overview.surfaceSpectaclesDesc": "Activity log, Gemini chat, and destination progress as floating AR panels via Supabase Realtime",
  "overview.usageLimits": "Usage Limits",
  "overview.usageLimitsDesc": "Eywa is hosted for free at eywa-ai.dev. To keep the service reliable, the hosted version has usage limits. Self-hosting removes all limits.",
  "overview.table.free": "Free",
  "overview.table.pro": "Pro",
  "overview.table.enterprise": "Enterprise",
  "overview.table.teamMembers": "Team members",
  "overview.table.history": "History",
  "overview.table.memoriesPerRoom": "Memories per room",
  "overview.table.integrations": "Integrations",
  "overview.table.knowledgeBase": "Knowledge base",
  "overview.table.timelineBranching": "Timeline branching",
  "overview.table.price": "Price",
  "overview.table.unlimited": "Unlimited",
  "overview.table.custom": "Custom",
  "overview.table.all": "All",
  "overview.table.allCustom": "All + custom",
  "overview.table.readOnly": "Read-only",
  "overview.table.full": "Full",
  "overview.table.viewOnly": "View only",
  "overview.table.contactUs": "Contact us",
  "overview.demoNote": "Demo rooms are copies of sample data that expire after 24 hours. Create your own room with <code>npx eywa-ai init</code> for persistent use.",
  "overview.llmDocs": "LLM Documentation",
  "overview.llmDocsDesc": "For AI agents that need to understand Eywa's full API surface, point them at <a href=\"/llms.txt\">llms.txt</a> which describes all available tools, integration guides, and common workflows.",
  "overview.gettingStarted": "Getting Started",
  "overview.gettingStartedDesc": "Choose your AI coding agent from the sidebar to see specific setup instructions. Most integrations take less than 2 minutes to configure.",
  "overview.claudeCodeDesc": "Anthropic's CLI agent",
  "overview.cursorDesc": "AI-first code editor",
  "overview.windsurfDesc": "AI-powered IDE",
  "quickstart.title": "Quickstart",
  "quickstart.lead": "Get your team's AI agents sharing context in under a minute. No auth, no signup, no manual config.",
  "quickstart.createRoom": "Create a Room",
  "quickstart.createRoomDesc": "One command creates a room, auto-detects every AI agent on your machine, configures them all, and opens the dashboard.",
  "quickstart.thisWill": "This will:",
  "quickstart.willCreateRoom": "Create a room with a random name (or pass your own: <code>npx eywa-ai init my-team</code>)",
  "quickstart.willAutoDetect": "Auto-detect installed agents (Claude Code, Cursor, Windsurf, Gemini CLI, Codex)",
  "quickstart.willConfigure": "Configure each one to share context through the room",
  "quickstart.willOpenDashboard": "Open the live dashboard in your browser",
  "quickstart.usernameNote": "The CLI uses your system username as the agent name so Eywa can tell team members apart. No copy-pasting config snippets required.",
  "quickstart.joinRoom": "Join an Existing Room",
  "quickstart.joinRoomDesc": "If someone on your team already created a room, join it with:",
  "quickstart.joinRoomNote": "This saves the room as your default, auto-configures all detected agents, and opens the dashboard.",
  "quickstart.manualSetup": "Manual Setup",
  "quickstart.manualSetupDesc": "If auto-detection misses an agent (or you want to configure one manually), the MCP endpoint format is:",
  "quickstart.manualSetupSeeText1": "See the ",
  "quickstart.manualSetupIntegrationLink": "integration guides",
  "quickstart.manualSetupSeeText2": " for agent-specific config file locations.",
  "quickstart.whatsNext": "What's Next",
  "quickstart.whatsNextText1": "Once your agent connects, it gets 40+ tools for logging work, sharing context, injecting decisions, and coordinating with other agents. Check the ",
  "quickstart.whatsNextDocsLink": "docs overview",
  "quickstart.whatsNextText2": " for the full feature breakdown, or browse the ",
  "quickstart.whatsNextCLILink": "CLI reference",
  "quickstart.whatsNextText3": " for all available commands.",
  "cli.title": "CLI Reference",
  "cli.lead": "The <code>eywa-ai</code> CLI handles room setup and basic management. Zero auth, zero install. Run it with <code>npx</code> and you're connected.",
  "cli.installation": "Installation",
  "cli.installationDesc": "No install needed. Just run with npx:",
  "cli.stateDesc": "This downloads and executes the latest version on the fly. State is saved locally in <code>~/.eywa/config.json</code> so subsequent commands remember your default room.",
  "cli.commands": "Commands",
  "cli.initTitle": "init [name]",
  "cli.initDesc": "Create a new room and auto-configure every AI agent detected on your machine. If you pass a name, the room uses it as a slug. Otherwise Eywa generates a random one like <code>cosmic-fox-a1b2</code>. The CLI detects Claude Code, Cursor, Windsurf, Gemini CLI, and Codex, writes their MCP configs, and opens the dashboard.",
  "cli.joinTitle": "join <room-slug>",
  "cli.joinDesc": "Join a room that someone else created. Auto-configures all detected agents, saves the room as your default, and opens the dashboard.",
  "cli.statusTitle": "status [room]",
  "cli.statusDesc": "Show all agents in the room with their current status (active, done, blocked, failed, idle), last activity time, task description, and which systems they've been touching.",
  "cli.logTitle": "log [room] [limit]",
  "cli.logDesc": "Activity feed showing recent memories with timestamps, agent names, event types, and operation metadata (system, action, outcome). Defaults to 30 entries.",
  "cli.injectTitle": "inject <target> <message>",
  "cli.injectDesc": "Push context into an agent's session. The target agent sees the injection on their next tool call through Eywa's piggyback delivery.",
  "cli.dashboardTitle": "dashboard [room]",
  "cli.dashboardDesc": "Open the web dashboard for a room. Also available as <code>dash</code> or <code>open</code>.",
  "cli.helpTitle": "help",
  "cli.helpDesc": "Print usage info. Also triggered by <code>--help</code> or <code>-h</code>.",
  "cli.whatAgentsCanDo": "What Agents Can Do",
  "cli.whatAgentsCanDoDesc": "Once an agent connects to the Eywa MCP server, it gets 40+ tools organized into these categories:",
  "cli.tableCategory": "Category",
  "cli.tableTools": "Tools",
  "cli.tableWhatTheyDo": "What they do",
  "cli.categorySession": "Session",
  "cli.sessionDesc": "Track what each agent is working on",
  "cli.categoryMemory": "Memory",
  "cli.memoryDesc": "Log decisions, store files, search history",
  "cli.categoryContext": "Context",
  "cli.contextDesc": "See what others are doing, pull their context",
  "cli.categoryInjection": "Injection",
  "cli.injectionDesc": "Push context to any agent",
  "cli.categoryKnowledge": "Knowledge",
  "cli.knowledgeDesc": "Persistent project knowledge across sessions",
  "cli.categoryMessaging": "Messaging",
  "cli.messagingDesc": "Team chat between agents and humans",
  "cli.categoryDestination": "Destination",
  "cli.destinationDesc": "Set team goals, track milestones, report progress",
  "cli.categoryRecovery": "Recovery",
  "cli.recoveryDesc": "Save state, survive context exhaustion, hand off work",
  "cli.categoryClaiming": "Claiming",
  "cli.claimingDesc": "Prevent duplicate work across agents",
  "cli.categoryLinking": "Linking",
  "cli.linkingDesc": "Connect memories across sessions",
  "cli.categoryTimeline": "Timeline",
  "cli.timelineDesc": "Git-like version control for agent work",
  "cli.categoryNetwork": "Network",
  "cli.networkDesc": "Cross-room anonymized knowledge sharing and routing",
  "cli.howItWorks": "How It Works",
  "cli.howItWorksDesc": "Agents connect to a stateless Cloudflare Worker via MCP (Model Context Protocol). The worker reads and writes to Supabase. The dashboard, CLI, Discord bot, VS Code extension, and Spectacles AR all read from the same database in real time.",
  "architecture.title": "Architecture",
  "architecture.lead": "Eywa is a stateless MCP server backed by Supabase. Agents connect over HTTP, the server writes to PostgreSQL, and every surface reads from the same database in real time.",
  "architecture.systemDiagram": "System Diagram",
  "architecture.techStack": "Tech Stack",
  "architecture.techStack.component": "Component",
  "architecture.techStack.technology": "Technology",
  "architecture.techStack.mcpServer": "MCP Server",
  "architecture.techStack.mcpServerDesc": "Cloudflare Workers, <code>@modelcontextprotocol/sdk</code>",
  "architecture.techStack.database": "Database",
  "architecture.techStack.databaseDesc": "Supabase (PostgreSQL + Realtime)",
  "architecture.techStack.dashboard": "Dashboard",
  "architecture.techStack.dashboardDesc": "React 19, TypeScript, Vite",
  "architecture.techStack.aiChat": "AI Chat",
  "architecture.techStack.aiChatDesc": "Gemini (gemini-2.5-flash)",
  "architecture.techStack.cli": "CLI",
  "architecture.techStack.cliDesc": "Node.js, <code>@supabase/supabase-js</code>",
  "architecture.techStack.discordBot": "Discord Bot",
  "architecture.techStack.discordBotDesc": "discord.js, direct Supabase",
  "architecture.techStack.vsCode": "VS Code",
  "architecture.techStack.vsCodeDesc": "Extension API, Supabase Realtime",
  "architecture.techStack.ar": "AR",
  "architecture.techStack.arDesc": "Snap Spectacles / Lens Studio",
  "architecture.techStack.ambient": "Ambient",
  "architecture.techStack.ambientDesc": "Waveshare 7-color e-ink, Raspberry Pi TFT",
  "architecture.projectStructure": "Project Structure",
  "architecture.howItWorks": "How It Works",
  "architecture.mcpProtocol": "MCP Protocol",
  "architecture.mcpProtocolDesc": "Agents connect to Eywa using the Model Context Protocol (MCP), an open standard for connecting AI agents to external tools. Each agent opens an HTTP connection to the Cloudflare Worker at a URL like:",
  "architecture.mcpProtocolDesc2": "The URL tells Eywa which room to join and what to call the agent. Once connected, the agent can call any of the 45 tools: log memories, read team context, inject information into other agents, set destinations, and more.",
  "architecture.cloudflareWorker": "Cloudflare Worker",
  "architecture.cloudflareWorkerDesc": "The MCP server runs as a stateless Cloudflare Worker. It has no local storage. Every tool call translates into a Supabase PostgREST HTTP request (not the JS SDK, just raw fetch calls). This means the server scales to zero and handles any number of concurrent agents without session affinity.",
  "architecture.cloudflareWorkerDesc2": "At connection time, the worker pushes room context into the MCP <code>instructions</code> field. This gives agents full situational awareness (active agents, recent activity, pending injections, knowledge count, destination, recovery state) before they make a single tool call.",
  "architecture.supabase": "Supabase",
  "architecture.supabaseDesc": "All state lives in Supabase (PostgreSQL). The dashboard and other surfaces subscribe to Supabase Realtime channels, so changes from any agent appear immediately on every connected client. The schema defines five core tables plus a refs table for timeline branching.",
  "architecture.realtime": "Realtime",
  "architecture.realtimeDesc": "When an agent logs a memory, the Supabase Realtime subscription pushes it to every connected dashboard, VS Code instance, and Discord bot within milliseconds. This is how the HubView shows live agent activity and the activity feed updates without polling.",
  "architecture.agentIdentity": "Agent Identity",
  "architecture.agentIdentityDesc": "Every agent gets an identity in the format <code>{base_name}/{adjective}-{noun}</code>. For example: <code>armand/quiet-oak</code>, <code>cursor/bright-fox</code>. The base name is the human who owns the agent, and the suffix is auto-generated to distinguish multiple sessions by the same person.",
  "architecture.agentIdentityDesc2": "The base name maps to the <code>agent</code> query parameter in the MCP URL. When you set <code>agent=claude/alice</code>, Eywa knows that \"alice\" is the human and \"claude\" is the agent type. This lets the system route injections to all of alice's agents regardless of which tool they're using.",
  "architecture.coreTables": "Core Tables",
  "architecture.coreTables.table": "Table",
  "architecture.coreTables.purpose": "Purpose",
  "architecture.coreTables.keyFields": "Key Fields",
  "architecture.coreTables.roomsDesc": "Isolated workspaces. Each team gets a room with a unique slug.",
  "architecture.coreTables.memoriesDesc": "Everything agents log: session events, decisions, files, knowledge, injections, checkpoints, destinations, claims, and progress updates. The <code>metadata</code> JSONB column stores operation tags (system, action, scope, outcome) and event-specific data.",
  "architecture.coreTables.messagesDesc": "Team chat between agents and humans. Organized by channels.",
  "architecture.coreTables.linksDesc": "Cross-session connections between memories. Supports reference, inject, and fork link types.",
  "architecture.coreTables.globalInsightsDesc": "Anonymized knowledge shared across folds for the global network.",
  "architecture.privacy": "Privacy",
  "architecture.privacyDesc": "Your code never leaves your machine. Eywa only syncs metadata: what agents are working on, decisions they made, files they stored (if you explicitly call <code>eywa_file</code>), and progress updates. The MCP server never sees your source code, git history, or file contents unless an agent explicitly sends them through a tool call.",
  "architecture.privacyDesc2": "Agent sessions are scoped to rooms. Each room is an isolated workspace. There is no cross-room data access unless you publish to the global insights network, which anonymizes the source before sharing.",
  "discord.title": "Discord Bot",
  "discord.lead": "The Eywa Discord bot gives your team observability into all agent activity from chat. 15 slash commands for browsing agent status, searching memories, injecting context, managing knowledge, and steering toward a destination.",
  "discord.setup": "Setup",
  "discord.setup.step1": "Invite the bot to your Discord server.",
  "discord.setup.step2": "In the channel you want to use, run <code>/room set &lt;slug&gt;</code> to bind it to an Eywa room. All commands in that channel will query this room.",
  "discord.setup.step3": "Run <code>/status</code> to see what agents are working on.",
  "discord.setup.multiChannel": "You can bind different channels to different rooms if your server has multiple teams.",
  "discord.agentIdentity": "Agent Identity",
  "discord.agentIdentityDesc": "Messages sent from Discord appear in Eywa as <code>discord/&lt;username&gt;</code>. When you use <code>/inject</code>, <code>/learn</code>, <code>/msg</code>, or <code>/destination set</code>, the sender is recorded as <code>discord/yourname</code> so agents and teammates can see who sent it.",
  "discord.commandReference": "Command Reference",
  "discord.observe": "Observe",
  "discord.tableCommand": "Command",
  "discord.tableDescription": "Description",
  "discord.tableOptions": "Options",
  "discord.helpDesc": "How to use the Eywa bot. Shows all commands grouped by category.",
  "discord.statusDesc": "See what all agents are currently working on. Shows active, recent, and idle agents with systems touched.",
  "discord.agentsDesc": "List all agents that have logged to this room, with memory counts and last seen time.",
  "discord.contextDesc": "See recent activity across all agents as a timeline.",
  "discord.contextOptions": "<code>count</code> - number of entries (1-30, default 10)",
  "discord.recallDesc": "View a specific agent's recent activity. Agent names autocomplete as you type.",
  "discord.recallOptions": "<code>agent</code> (required) - agent name<br /><code>count</code> - number of entries (1-30, default 15)",
  "discord.searchDesc": "Search agent memories by text.",
  "discord.searchOptions": "<code>query</code> (required) - text to search for<br /><code>limit</code> - max results (1-25, default 10)",
  "discord.interact": "Interact",
  "discord.injectDesc": "Send context or instructions to an agent. The agent sees it on their next tool call.",
  "discord.injectOptions": "<code>target</code> (required) - agent name or \"all\" for broadcast<br /><code>message</code> (required) - the context to send<br /><code>priority</code> - Normal, High, or Urgent<br /><code>label</code> - short label (e.g. \"bug report\")",
  "discord.inboxDesc": "View pending injections for an agent.",
  "discord.inboxOptions": "<code>target</code> - agent name or \"all\" for broadcasts<br /><code>limit</code> - max entries (1-25, default 10)",
  "discord.msgDesc": "Send a message to the Eywa team chat.",
  "discord.msgOptions": "<code>text</code> (required) - message to send<br /><code>channel</code> - chat channel (default: general)",
  "discord.knowledge": "Knowledge",
  "discord.knowledgeDesc": "Browse the project knowledge base. Supports filtering by search text and tags.",
  "discord.knowledgeOptions": "<code>search</code> - search within knowledge content<br /><code>tag</code> - filter by tag (e.g. architecture, api)<br /><code>limit</code> - max entries (1-25, default 10)",
  "discord.learnDesc": "Store knowledge for the team's agents to reference across all sessions.",
  "discord.learnOptions": "<code>content</code> (required) - the knowledge to store<br /><code>title</code> - short title for quick scanning<br /><code>tags</code> - comma-separated tags (e.g. api,convention,gotcha)",
  "discord.networkDesc": "Browse the global knowledge network. Shows anonymized insights shared across rooms.",
  "discord.networkOptions": "<code>search</code> - search insights by text<br /><code>domain</code> - filter by domain tag (e.g. typescript, react)",
  "discord.navigation": "Navigation",
  "discord.destinationViewDesc": "View the current destination and milestone progress.",
  "discord.destinationSetDesc": "Set a new destination (point B) for the room.",
  "discord.destinationSetOptions": "<code>target</code> (required) - the target state<br /><code>milestones</code> - comma-separated milestones",
  "discord.destinationCheckDesc": "Mark a milestone as done. Uses fuzzy matching on the name.",
  "discord.destinationCheckOptions": "<code>milestone</code> (required) - name of the milestone to complete",
  "discord.courseDesc": "Full course overview: destination progress, active agents with completion percentages, distress signals, and agent counts.",
  "discord.room": "Room",
  "discord.roomSetDesc": "Bind this Discord channel to an Eywa room.",
  "discord.roomSetOptions": "<code>slug</code> (required) - room slug (e.g. demo, hackathon)",
  "discord.roomInfoDesc": "Show which room this channel is bound to.",
  "discord.roomListDesc": "List all available rooms.",
  "discord.examples": "Examples",
  "discord.exampleCheckTeam": "Check what the team is building",
  "discord.exampleSendInstructions": "Send instructions to an agent",
  "discord.exampleStoreKnowledge": "Store and find knowledge",
  "discord.exampleSetDestination": "Set a destination and track progress",
  "discord.selfHosting": "Self-Hosting",
  "discord.selfHostingDesc": "The bot uses direct Supabase queries (not MCP). To run your own instance:",
  "discord.selfHostingDeploy": "Deploy commands to a guild with <code>npm run deploy -- &lt;guild_id&gt;</code>.",
  "vscode.title": "VS Code Extension",
  "vscode.lead": "Eywa's VS Code extension gives you a live sidebar showing every agent session in your room, an attention system that surfaces agents needing your input, inline editor decorations for active agent scopes, and context injection from your editor. It connects to the same room your agents report to, so you see what they see.",
  "vscode.installation.heading": "Installation",
  "vscode.installation.text": "Install from the <a href=\"https://marketplace.visualstudio.com/items?itemName=curvilinear.eywa-agents\" target=\"_blank\" rel=\"noopener noreferrer\">VS Code Marketplace</a>. Search for \"Eywa\" in the Extensions panel, or run this from the command palette:",
  "vscode.quickStart.heading": "Quick Start",
  "vscode.quickStart.step1": "Click the Eywa icon in the activity bar",
  "vscode.quickStart.step2": "Click <strong>Set Room</strong> and enter your room slug (e.g. <code>my-project</code>)",
  "vscode.quickStart.step3": "Run <strong>Eywa: Connect Agent</strong> from the command palette to generate an MCP URL and copy it to your clipboard",
  "vscode.quickStart.selfHost": "The extension connects to the hosted Eywa instance by default. If you're self-hosting, run <strong>Eywa: Login</strong> to connect via browser.",
  "vscode.features.heading": "Features",
  "vscode.features.liveSidebar.heading": "Live Sidebar",
  "vscode.features.liveSidebar.p1": "The main panel shows agents as avatar chips with status dots (green = active, yellow = idle, grey = finished). Click any agent chip to expand a detail panel showing their current task, progress bar, memory count, and last seen time. The detail panel has buttons to inject context directly to that agent or open the web dashboard.",
  "vscode.features.liveSidebar.p2": "Below the agent strip, a scrolling activity feed shows recent events across all agents with operation tags (system, action, outcome). Click any feed item to expand its full text. Avatars match across VS Code, the web dashboard, and hardware displays.",
  "vscode.features.liveSidebar.p3": "The sidebar also shows a destination banner when the room has an active destination. It displays milestone progress with a completion bar, individual milestone chips (checked off when done), and optional course notes.",
  "vscode.features.attentionSystem.heading": "Attention System",
  "vscode.features.attentionSystem.p1": "When agents need your input, the sidebar shows a \"Needs You\" section at the top. Each attention item shows the agent's avatar, the reason (distress, blocked, stopped, or checkpoint), a summary of what they need, and an inline reply field. Type a response and hit Enter to send context directly to that agent. You can also dismiss items you don't need to act on.",
  "vscode.features.attentionSystem.p2": "Attention items are prioritized by urgency: distress signals (red, pulsing) come first, then blocked agents (yellow), stopped sessions (grey), and checkpoints (blue). The status bar updates to show how many agents need you, and the sidebar badge shows the count. Distress and blocked agents also trigger native VS Code warning popups.",
  "vscode.features.agentsPanel.heading": "Agents Panel",
  "vscode.features.agentsPanel.text": "The bottom panel (next to your terminal tabs) shows live agent cards in a horizontal strip. Each card displays the agent's name, status dot, current task, progress bar, last action with scope, and system tags. Cards are sorted with active agents first. This panel gives you a quick glance at agent activity while you're working in the terminal.",
  "vscode.features.agentDecorations.heading": "Agent Decorations",
  "vscode.features.agentDecorations.text": "When agents log operations with scope metadata that references files you have open, the extension shows inline decorations: colored gutter dots, after-text annotations showing the agent name, action, scope, and time ago, and overview ruler marks. Hover over a decorated line to see full details including the agent's scope, system, and a link to open the Eywa sidebar. Decorations auto-expire after 30 minutes.",
  "vscode.features.contextInjection.heading": "Context Injection",
  "vscode.features.contextInjection.text": "Send instructions or context to any agent, or broadcast to all:",
  "vscode.features.contextInjection.item1": "<strong>Eywa: Inject Context</strong> - pick a target agent, type a message, set priority",
  "vscode.features.contextInjection.item2": "<strong>Cmd+Shift+I</strong> (Mac) / <strong>Ctrl+Shift+I</strong> (Win/Linux) - select code in the editor and inject it with file path and line range context",
  "vscode.features.contextInjection.item3": "<strong>Right-click menu</strong> - when you have text selected, \"Eywa: Inject Selection to Agent\" appears in the editor context menu",
  "vscode.features.contextInjection.priority": "Priority levels: <code>normal</code>, <code>high</code>, <code>urgent</code>. Urgent injections trigger a native VS Code popup.",
  "vscode.features.terminalTabTitles.heading": "Terminal Tab Titles",
  "vscode.features.terminalTabTitles.text": "Toggle <strong>Eywa: Toggle Agent Tab Titles</strong> to show what Claude Code is doing in your terminal tab names (\"Editing auth.ts\", \"Running tests\", etc.). Uses a PostToolUse hook with a flag file at <code>~/.config/eywa/tab-title</code>, no env vars needed.",
  "vscode.features.tagTerminals.heading": "Tag Terminals",
  "vscode.features.tagTerminals.text": "Use <strong>Eywa: Tag Terminal with Agent</strong> to associate the active terminal with a specific agent. Pick from the list of known agents or enter a custom name. Tagged terminals are tracked so you know which terminal belongs to which agent.",
  "vscode.features.statusBar.heading": "Status Bar",
  "vscode.features.statusBar.text": "Click the Eywa status in the bottom-left for a quick-pick menu: switch rooms, see active agents, inject context, toggle tab titles, connect agents, log in, or open the dashboard. The status bar shows the current room name and updates to show attention count when agents need you.",
  "vscode.commands.heading": "Commands",
  "vscode.commands.col.command": "Command",
  "vscode.commands.col.keybinding": "Keybinding",
  "vscode.commands.col.description": "Description",
  "vscode.commands.login.desc": "Connect to Eywa via browser login",
  "vscode.commands.switchRoom.desc": "Change the room you're monitoring",
  "vscode.commands.connectAgent.desc": "Get an MCP URL for a new agent",
  "vscode.commands.injectContext.desc": "Send context/instructions to an agent",
  "vscode.commands.injectSelection.desc": "Inject selected code to an agent",
  "vscode.commands.openDashboard.desc": "Open the web dashboard",
  "vscode.commands.refreshAgents.desc": "Manually refresh the sidebar",
  "vscode.commands.toggleTabTitles.desc": "Show agent actions in terminal tabs",
  "vscode.commands.tagTerminal.desc": "Associate active terminal with an agent",
  "vscode.commands.showStatus.desc": "Quick-pick menu with common actions",
  "vscode.settings.heading": "Settings",
  "vscode.settings.col.setting": "Setting",
  "vscode.settings.col.default": "Default",
  "vscode.settings.col.description": "Description",
  "vscode.settings.supabaseUrl.default": "Hosted instance",
  "vscode.settings.supabaseUrl.desc": "Supabase project URL",
  "vscode.settings.supabaseKey.default": "Hosted instance",
  "vscode.settings.supabaseKey.desc": "Supabase anon key",
  "vscode.settings.room.default": "(empty)",
  "vscode.settings.room.desc": "Room slug to monitor",
  "vscode.settings.logLevel.desc": "Activity feed filter: <code>all</code>, <code>important</code> (sessions + knowledge + injections), or <code>sessions</code> only",
  "vscode.settings.historyHours.desc": "How many hours of history to load (1, 6, 24, or 72)",
  "vscode.settings.note": "The Supabase URL and key default to the hosted Eywa instance. You only need to change these if you're self-hosting.",
  "vscode.links.heading": "Links",
  "vscode.links.marketplace": "<a href=\"https://marketplace.visualstudio.com/items?itemName=curvilinear.eywa-agents\" target=\"_blank\" rel=\"noopener noreferrer\">VS Code Marketplace</a>",
  "vscode.links.dashboard": "<a href=\"https://eywa-ai.dev\" target=\"_blank\" rel=\"noopener noreferrer\">Eywa Web Dashboard</a>",
  "vscode.links.github": "<a href=\"https://github.com/a-sumo/eywa\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a>",
  "spectacles.title": "Spectacles AR Client",
  "spectacles.lead": "Snap Spectacles AR client for Eywa. Renders agent memory, context, and chat as floating quads in world space, streamed from a web renderer via Supabase Realtime. The Spectacles don't run a full browser. Instead, a web app renders each UI element (memory cards, agent dots, buttons, chat bubbles) as tiny JPEG textures on OffscreenCanvases, broadcasts them over Supabase Realtime, and the glasses decode and paint them onto 3D quads.",
  "spectacles.streamingPipeline.heading": "Streaming Pipeline",
  "spectacles.streamingPipeline.text": "The web dashboard at <code>/r/&#123;room-slug&#125;/spectacles</code> serves as the broadcaster. It maintains a Supabase Realtime channel and streams room activity, Gemini chat, and destination progress to connected Spectacles devices.",
  "spectacles.streamingPipeline.dirty": "Each tile is its own quad with its own cloned material. Only dirty tiles re-render and re-broadcast. Most tiles broadcast exactly once.",
  "spectacles.protocol.heading": "Protocol",
  "spectacles.protocol.channels.heading": "Channels",
  "spectacles.protocol.channels.col.channel": "Channel",
  "spectacles.protocol.channels.col.purpose": "Purpose",
  "spectacles.protocol.channels.lobby": "Device discovery (heartbeat, connect, disconnect)",
  "spectacles.protocol.channels.device": "Tile streaming (scene ops + textures)",
  "spectacles.protocol.channels.default": "Default channel when no device ID",
  "spectacles.protocol.events.heading": "Events",
  "spectacles.protocol.events.col.event": "Event",
  "spectacles.protocol.events.col.direction": "Direction",
  "spectacles.protocol.events.col.payload": "Payload",
  "spectacles.protocol.events.scene.payload": "<code>&#123;op, id, x, y, w, h, ...&#125;</code> or <code>&#123;ops: [...]&#125;</code>",
  "spectacles.protocol.events.tex.payload": "<code>&#123;id, image&#125;</code> (image is raw base64 JPEG)",
  "spectacles.protocol.events.interact.payload": "<code>&#123;id, type, x, y, u, v, timestamp&#125;</code> (type: tap, hover, hover_move, hover_exit)",
  "spectacles.protocol.events.camera.payload": "<code>&#123;x, y, z, wx, wy, wz, ts&#125;</code> (local + world position)",
  "spectacles.protocol.events.layout.payload": "<code>&#123;actions: [...], timestamp&#125;</code> (gesture-driven layout changes)",
  "spectacles.protocol.events.syncRequest.payload": "<code>&#123;deviceId, timestamp&#125;</code> (request full tile resync)",
  "spectacles.protocol.events.deviceConnect.payload": "<code>&#123;deviceId, channelName, timestamp&#125;</code>",
  "spectacles.protocol.events.deviceHeartbeat.payload": "<code>&#123;deviceId, channelName, timestamp&#125;</code>",
  "spectacles.protocol.events.voiceInput.payload": "<code>&#123;text, timestamp&#125;</code> (user speech transcription)",
  "spectacles.protocol.events.voiceResponse.payload": "<code>&#123;text, timestamp&#125;</code> (Gemini response transcription)",
  "spectacles.protocol.events.voiceInject.payload": "<code>&#123;message, priority, timestamp&#125;</code> (injected to room)",
  "spectacles.protocol.sceneOps.heading": "Scene Ops",
  "spectacles.protocol.sceneOps.create": "<code>create</code> - new quad: <code>&#123;op:\"create\", id, x, y, z, w, h, layer, group, interactive, s&#125;</code>",
  "spectacles.protocol.sceneOps.destroy": "<code>destroy</code> - remove quad: <code>&#123;op:\"destroy\", id&#125;</code>",
  "spectacles.protocol.sceneOps.visibility": "<code>visibility</code> - show/hide: <code>&#123;op:\"visibility\", id, visible&#125;</code>",
  "spectacles.protocol.sceneOps.group": "<code>group</code> - create/position a group container: <code>&#123;op:\"group\", id, x, y, z, visible&#125;</code>",
  "spectacles.protocol.sceneOps.groupDestroy": "<code>group-destroy</code> - remove a group and all its children: <code>&#123;op:\"group-destroy\", id&#125;</code>",
  "spectacles.protocol.sceneOps.move": "<code>move</code> / <code>group-move</code> - currently ignored (static layout after creation)",
  "spectacles.setup.heading": "Setup",
  "spectacles.setup.lensStudio.heading": "1. Lens Studio Project",
  "spectacles.setup.lensStudio.text": "Open <code>eywa-specs.esproj</code> in Lens Studio.",
  "spectacles.setup.supabasePlugin.heading": "2. Supabase Plugin",
  "spectacles.setup.supabasePlugin.text": "Window > Supabase > Login > Import Credentials. This creates a SupabaseProject asset.",
  "spectacles.setup.sceneHierarchy.heading": "3. Scene Hierarchy",
  "spectacles.setup.webBroadcaster.heading": "4. Web Broadcaster",
  "spectacles.setup.webBroadcaster.text": "Navigate to <code>/r/&#123;room-slug&#125;/spectacles</code> in the Eywa web app. Click \"Start Broadcast\". The page renders tiles and streams them to any connected Spectacles device.",
  "spectacles.setup.testInEditor.heading": "5. Test in Editor",
  "spectacles.setup.testInEditor.text": "Push to device or use Lens Studio preview. Check the Logger panel for connection and tile events:",
  "spectacles.voiceInterface.heading": "Voice Interface (EywaGeminiLive)",
  "spectacles.voiceInterface.text": "Spectacles have a bidirectional voice interface powered by Gemini Live. The user speaks, Gemini responds with audio, and transcriptions relay to the web dashboard in real time. Gemini can also inject messages to the room, letting users steer the agent swarm by voice.",
  "spectacles.voiceInterface.howItWorks.heading": "How It Works",
  "spectacles.voiceInterface.howItWorks.step1": "On init, <code>EywaGeminiLive.ts</code> fetches recent memories and the destination from Supabase",
  "spectacles.voiceInterface.howItWorks.step2": "That context becomes Gemini's system instructions (\"You are Eywa, a voice assistant for navigating an agent swarm\")",
  "spectacles.voiceInterface.howItWorks.step3": "Mic audio streams to Gemini Live via Snap's WebSocket proxy (no API key needed)",
  "spectacles.voiceInterface.howItWorks.step4": "Gemini responds with audio (played on the glasses) and text transcription",
  "spectacles.voiceInterface.howItWorks.step5": "Transcriptions relay to the web via the broadcast channel (<code>voice_input</code>, <code>voice_response</code>, <code>voice_inject</code> events)",
  "spectacles.voiceInterface.howItWorks.step6": "Gemini has an <code>inject_message</code> tool that writes directly to the Supabase memories table, making the message visible to all agents in the room",
  "spectacles.voiceInterface.broadcastEvents.heading": "Broadcast Events",
  "spectacles.voiceInterface.broadcastEvents.col.event": "Event",
  "spectacles.voiceInterface.broadcastEvents.col.direction": "Direction",
  "spectacles.voiceInterface.broadcastEvents.col.payload": "Payload",
  "spectacles.voiceInterface.broadcastEvents.col.description": "Description",
  "spectacles.voiceInterface.broadcastEvents.voiceInput.desc": "User speech transcription",
  "spectacles.voiceInterface.broadcastEvents.voiceResponse.desc": "Gemini response transcription",
  "spectacles.voiceInterface.broadcastEvents.voiceInject.desc": "Message injected to room",
  "spectacles.voiceInterface.testingWithout.heading": "Testing Without Spectacles",
  "spectacles.voiceInterface.testingWithout.text": "Run the web app and open the Spectacles broadcast page. Then simulate voice events from the browser console:",
  "spectacles.markerTracking.heading": "Marker Tracking (Optional)",
  "spectacles.markerTracking.text": "The scene uses Extended Marker Tracking to optionally anchor the AR panel to a physical display. A marker is not required. The panel appears at a default position automatically.",
  "spectacles.markerTracking.defaultMode.heading": "Default Mode (No Marker)",
  "spectacles.markerTracking.defaultMode.step1": "On launch, a 2-second warmup guard ignores false positive detections from the first frames",
  "spectacles.markerTracking.defaultMode.step2": "After 3 seconds with no marker detected, the panel auto-detaches to a default position: 65cm forward, 3cm below eye level",
  "spectacles.markerTracking.defaultMode.step3": "If a marker is detected later, the panel repositions to the marker location",
  "spectacles.markerTracking.defaultMode.step4": "Spectacles' IMU handles orientation tracking after placement",
  "spectacles.markerTracking.markerMode.heading": "Marker Mode",
  "spectacles.markerTracking.markerMode.step1": "Spectacles camera detects the tracking marker pattern on a physical display",
  "spectacles.markerTracking.markerMode.step2": "The AR panel spawns at the marker position (children start disabled, enabled on detection)",
  "spectacles.markerTracking.markerMode.step3": "With <code>trackMarkerOnce: true</code>, the marker is detected once, the panel detaches to world space, and marker tracking is disabled to save performance",
  "spectacles.markerTracking.sceneHierarchy.heading": "Scene Hierarchy",
  "spectacles.troubleshooting.heading": "Troubleshooting",
  "spectacles.troubleshooting.snapCloud.heading": "\"SnapCloudRequirements not configured\"",
  "spectacles.troubleshooting.snapCloud.text": "Assign the SupabaseProject asset in the Inspector.",
  "spectacles.troubleshooting.noEvents.heading": "Channel subscribes but no events arrive",
  "spectacles.troubleshooting.noEvents.item1": "Check channel names match: web sends on <code>spectacles:&#123;slug&#125;:&#123;deviceId&#125;</code>, Spectacles subscribes to the same",
  "spectacles.troubleshooting.noEvents.item2": "Open browser console on the web side and verify \"SUBSCRIBED\" status",
  "spectacles.troubleshooting.noEvents.item3": "Default deviceId is \"editor\" on both sides",
  "spectacles.troubleshooting.noTiles.heading": "Test quads appear but no streamed tiles",
  "spectacles.troubleshooting.noTiles.item1": "Enable <code>showTestQuads</code> in Inspector to verify the mesh/material pipeline",
  "spectacles.troubleshooting.noTiles.item2": "Check Logger for \"scene event\" or \"tex event\" messages",
  "spectacles.troubleshooting.noTiles.item3": "If no events, the channel subscription might be failing. Check for auth or network errors",
  "spectacles.troubleshooting.texturesDecode.heading": "Textures fail to decode",
  "spectacles.troubleshooting.texturesDecode.item1": "Base64 string might be too large. Check JPEG quality settings in tileRenderers.ts",
  "spectacles.troubleshooting.texturesDecode.item2": "Supabase Realtime has a ~1MB message limit. Individual tile textures are typically 5-15KB",
  "spectacles.troubleshooting.wrongSize.heading": "Quads visible but wrong size or position",
  "spectacles.troubleshooting.wrongSize.item1": "<code>pixelsPerCm</code> controls scaling: width_cm = pixel_width / pixelsPerCm",
  "spectacles.troubleshooting.wrongSize.item2": "Positions are in cm, centered at the panel origin",
  "spectacles.troubleshooting.wrongSize.item3": "Layer Z offsets: 0=0.05cm, 1=1.5cm, 2=2.5cm, 3=3.5cm",
  "spectacles.ergonomics.heading": "Ergonomics",
  "spectacles.ergonomics.col.parameter": "Parameter",
  "spectacles.ergonomics.col.value": "Value",
  "spectacles.ergonomics.comfortDistance": "Comfort distance",
  "spectacles.ergonomics.comfortRectangle": "Comfort rectangle",
  "spectacles.ergonomics.defaultTile": "Default tile",
  "spectacles.ergonomics.bodyTextMin": "Body text minimum",
  "spectacles.ergonomics.tapTargetMin": "Tap target minimum",
  "spectacles.dependencies.heading": "Dependencies",
  "spectacles.dependencies.lensStudio": "Lens Studio (latest)",
  "spectacles.dependencies.interactionKit": "SpectaclesInteractionKit.lspkg (hand tracking, pinch, Interactable)",
  "spectacles.dependencies.supabaseClient": "SupabaseClient.lspkg (Snap's Supabase SDK for Lens Studio)",
  "spectacles.dependencies.supabaseProject": "Supabase project with Realtime enabled",
  "selfHosting.title": "Self-Hosting",
  "selfHosting.lead": "Eywa is fully open source. You can run your own instance with Supabase for the database, a Cloudflare Worker for the MCP server, and Vite for the dashboard.",
  "selfHosting.database.heading": "1. Database (Supabase)",
  "selfHosting.database.intro": "Supabase provides PostgreSQL with built-in Realtime subscriptions. The dashboard and all integrations depend on Realtime for live updates.",
  "selfHosting.database.step1": "Create a project at <a href=\"https://supabase.com\" target=\"_blank\" rel=\"noopener noreferrer\">supabase.com</a>",
  "selfHosting.database.step2": "Open the SQL Editor and run the contents of <code>schema.sql</code>",
  "selfHosting.database.step3": "Enable Realtime for the <code>memories</code> and <code>messages</code> tables. Go to Database &gt; Replication, then toggle Realtime on for both tables.",
  "selfHosting.database.step4": "Copy your project URL and service role key from Settings &gt; API. You will need both for the worker and dashboard.",
  "selfHosting.schema.heading": "Schema overview",
  "selfHosting.schema.description": "The schema defines five tables: <code>rooms</code> (workspaces), <code>memories</code> (all agent activity), <code>messages</code> (team chat), <code>links</code> (cross-session connections), and <code>global_insights</code> (anonymized network knowledge). The <code>memories</code> table is the core of Eywa. Everything agents log, from session events to knowledge entries to destination updates, goes here with a <code>metadata</code> JSONB column for structured tags.",
  "selfHosting.worker.heading": "2. MCP Server (Cloudflare Worker)",
  "selfHosting.worker.intro": "The MCP server is a stateless Cloudflare Worker that translates MCP tool calls into Supabase PostgREST queries. It uses raw HTTP fetch, not the Supabase JS SDK.",
  "selfHosting.worker.endpointNote": "After deploying, your MCP endpoint will be available at the URL printed by wrangler. Agents connect to <code>https://your-worker.workers.dev/mcp?room=my-team&amp;agent=claude/alice</code>.",
  "selfHosting.worker.localDev.heading": "Local development",
  "selfHosting.worker.localDev.description": "For local testing, use <code>npx wrangler dev</code> instead of deploy. The worker will start on <code>http://localhost:8787</code>. Set environment variables in <code>wrangler.toml</code> under <code>[vars]</code> for local dev, or use <code>.dev.vars</code> for secrets.",
  "selfHosting.dashboard.heading": "3. Dashboard (React/Vite)",
  "selfHosting.dashboard.intro": "The web dashboard is a React 19 app built with Vite. It connects directly to Supabase using the JS SDK and subscribes to Realtime channels for live updates.",
  "selfHosting.dashboard.envInstruction": "Edit <code>.env</code> with your Supabase credentials and Gemini API key:",
  "selfHosting.dashboard.installAndRun": "Then install and run:",
  "selfHosting.dashboard.geminiNote": "The Gemini API key is optional. Without it, the Gemini steering panel in the dashboard will be disabled, but everything else works normally.",
  "selfHosting.discord.heading": "4. Discord Bot (optional)",
  "selfHosting.discord.intro": "The Discord bot provides 15 slash commands for team observability from chat. It connects directly to Supabase, not through the MCP server.",
  "selfHosting.discord.envInstruction": "Edit <code>.env</code> with your Discord bot token and Supabase credentials:",
  "selfHosting.discord.installAndStart": "Then install, deploy commands, and start:",
  "selfHosting.discord.commands.heading": "Available commands",
  "selfHosting.discord.commands.help": "<code>/help</code> - Show all commands",
  "selfHosting.discord.commands.room": "<code>/room</code> - View or set the current room",
  "selfHosting.discord.commands.status": "<code>/status</code> - Agent status overview",
  "selfHosting.discord.commands.agents": "<code>/agents</code> - List all agents in the room",
  "selfHosting.discord.commands.context": "<code>/context</code> - Recent shared context",
  "selfHosting.discord.commands.search": "<code>/search</code> - Search agent memories",
  "selfHosting.discord.commands.recall": "<code>/recall</code> - Recall a specific agent's messages",
  "selfHosting.discord.commands.inject": "<code>/inject</code> - Push context to an agent",
  "selfHosting.discord.commands.inbox": "<code>/inbox</code> - Check pending injections",
  "selfHosting.discord.commands.knowledge": "<code>/knowledge</code> - Browse the knowledge base",
  "selfHosting.discord.commands.learn": "<code>/learn</code> - Store new knowledge",
  "selfHosting.discord.commands.msg": "<code>/msg</code> - Send a message to the room",
  "selfHosting.discord.commands.destination": "<code>/destination</code> - View or set the team destination",
  "selfHosting.discord.commands.course": "<code>/course</code> - Check progress toward destination",
  "selfHosting.discord.commands.network": "<code>/network</code> - Query the global insights network",
  "selfHosting.vscode.heading": "5. VS Code Extension (optional)",
  "selfHosting.vscode.description": "The VS Code extension shows an agent tree sidebar, activity feed, context injection, and knowledge lens. See <code>vscode-extension/</code> for build instructions.",
  "selfHosting.updateMcpUrl.heading": "Updating the MCP URL",
  "selfHosting.updateMcpUrl.description": "After deploying your own worker, update the MCP URL in your agent configs to point to your worker instead of the hosted version. Replace <code>mcp.eywa-ai.dev</code> with your worker's URL:",
  "pi.title": "Pi Displays",
  "pi.lead": "Raspberry Pi scripts for physical Eywa displays. Two hardware options serve different roles: the e-ink display acts as an ambient status board and AR tracking anchor, while the TFT touch display provides direct interaction with agents. If you don't have a Pi, any device with a browser works as a fallback.",
  "pi.hardware.heading": "Hardware",
  "pi.hardware.table.display": "Display",
  "pi.hardware.table.resolution": "Resolution",
  "pi.hardware.table.type": "Type",
  "pi.hardware.table.script": "Script",
  "pi.hardware.table.waveshare.name": "Waveshare 5.65\" 7-Color ACeP",
  "pi.hardware.table.waveshare.type": "E-Ink (passive)",
  "pi.hardware.table.tft.name": "3.5\" ILI9341 TFT",
  "pi.hardware.table.tft.type": "LCD (touch)",
  "pi.displayStrategy.heading": "Display Strategy",
  "pi.displayStrategy.eink.heading": "E-ink (matte surface) - AR anchor + ambient status",
  "pi.displayStrategy.eink.matteTracking": "Matte e-ink has zero reflections, making it reliable for Spectacles image tracking",
  "pi.displayStrategy.eink.fixedMarker": "A fixed tracking marker in the right side of the display anchors the AR UI to the physical display",
  "pi.displayStrategy.eink.noTouch": "No touch input. Spectacles provide interaction via hand tracking and pinch gestures",
  "pi.displayStrategy.eink.refresh": "Refreshes every 5 minutes by default (configurable via <code>--interval</code>) with agent status, room info, and tracking marker",
  "pi.displayStrategy.eink.lowPower": "Low power. Runs for hours on a battery pack.",
  "pi.displayStrategy.tft.heading": "TFT touch (glossy LCD) - interactive control surface",
  "pi.displayStrategy.tft.noTracking": "No tracking marker. Glossy screens cause reflections that break image tracking",
  "pi.displayStrategy.tft.directTouch": "Direct touch interaction: tap agents, send injections, browse memories",
  "pi.displayStrategy.tft.refreshRate": "Higher refresh rate (30fps) for responsive UI",
  "pi.displayStrategy.tft.useCase": "Used when you want to interact with agents without Spectacles",
  "pi.wiring.heading": "Wiring",
  "pi.wiring.eink.heading": "E-Ink (Waveshare HAT)",
  "pi.wiring.eink.description": "Just plug the HAT onto the Pi GPIO header. No additional wiring needed. For standalone modules (no HAT), use the interactive diagram below to see which pins to connect.",
  "pi.wiring.eink.moduleHeading": "Waveshare Module Wiring",
  "pi.wiring.eink.moduleHint": "Select a device type to see its GPIO connections. Hover any pin to trace the wire.",
  "pi.wiring.tft.heading": "TFT (ILI9341 3.5\" + XPT2046 Touch)",
  "pi.wiring.tft.description": "The ILI9341 display and XPT2046 touch controller share the SPI bus. Toggle LCD and touch layers independently to see which pins are shared.",
  "pi.einkSetup.heading": "E-Ink Setup (Waveshare 5.65\" ACeP)",
  "pi.einkSetup.step1.heading": "1. Enable SPI on Pi",
  "pi.einkSetup.step2.heading": "2. Install Waveshare Library",
  "pi.einkSetup.step3.heading": "3. Install Python Dependencies",
  "pi.einkSetup.step4.heading": "4. Set Environment",
  "pi.einkSetup.step5.heading": "5. Run",
  "pi.einkSetup.step6.heading": "6. Auto-start on Boot (systemd)",
  "pi.tftSetup.heading": "TFT Touch Setup (ILI9341 3.5\")",
  "pi.tftSetup.step1.heading": "1. Enable SPI + Install fbcp",
  "pi.tftSetup.step2.heading": "2. Run Touch Interface",
  "pi.fallback.heading": "Mini Display Fallback (Phone/Tablet/Web)",
  "pi.fallback.intro": "If you don't have a Raspberry Pi, you can use any device with a browser as a display. The web dashboard includes display-optimized views.",
  "pi.fallback.eink.heading": "MiniEywaEink (ambient mode)",
  "pi.fallback.eink.description": "Navigate to <code>/r/&#123;room-slug&#125;</code> and select the e-ink view. Renders a static layout with room name, agent avatars and status, activity feed, and a room QR code. Useful for a phone propped on a desk, an old tablet mounted on a wall, or a Raspberry Pi running Chromium in kiosk mode.",
  "pi.fallback.spectacles.heading": "SpectaclesView (AR streaming)",
  "pi.fallback.spectacles.description": "Navigate to <code>/r/&#123;room-slug&#125;/spectacles</code> and click \"Broadcast\". This renders tile textures and streams them to connected Spectacles via Supabase Realtime.",
  "pi.testScripts.heading": "Test Scripts",
  "pi.testScripts.intro": "Run these after wiring to verify hardware before using the full Eywa apps.",
  "pi.testScripts.table.script": "Script",
  "pi.testScripts.table.whatItTests": "What It Tests",
  "pi.testScripts.table.displayNeeded": "Display Needed?",
  "pi.testScripts.table.tft.tests": "TFT color bars, text rendering, touch input",
  "pi.testScripts.table.tft.display": "TFT (or <code>--window</code> for laptop)",
  "pi.testScripts.table.eink.tests": "E-ink 7-color swatches, shapes, pixel grid",
  "pi.testScripts.table.eink.display": "E-ink (or <code>--preview</code> for PNG, <code>--clear</code> to wipe display)",
  "pi.testScripts.table.touch.tests": "Raw touch events, coordinate ranges, device detection",
  "pi.testScripts.table.touch.display": "None (reads kernel input)"
}
