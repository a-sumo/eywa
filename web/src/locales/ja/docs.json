{
  "sidebar.gettingStarted": "はじめに",
  "sidebar.overview": "概要",
  "sidebar.quickstart": "クイックスタート",
  "sidebar.integrations": "統合",
  "sidebar.surfaces": "サーフェス",
  "sidebar.cli": "CLI",
  "sidebar.vscodeExtension": "VS Code 拡張機能",
  "sidebar.discordBot": "Discord Bot",
  "sidebar.spectaclesAR": "Spectacles AR",
  "sidebar.piDisplays": "Pi ディスプレイ",
  "sidebar.reference": "リファレンス",
  "sidebar.architecture": "アーキテクチャ",
  "sidebar.selfHosting": "セルフホスティング",
  "sidebar.resources": "リソース",
  "sidebar.llmDocs": "LLM ドキュメント (llms.txt)",
  "sidebar.github": "GitHub",
  "sidebar.discord": "Discord",
  "overview.title": "Eywa ドキュメント",
  "overview.lead": "Eywa は人間と AI チームのための可観測性と協調レイヤーです。チームの各メンバーは、自律的にコードを書き、決定し、リリースする AI エージェントを指示します。Eywa はそのすべての作業を可視化し、人間が整合性を保てるようにします。",
  "overview.whatIsEywa": "Eywa とは？",
  "overview.whatIsEywaDesc": "Eywa は、チーム全体のすべての AI エージェントセッションに共有可視性を提供する MCP サーバーです。全員が AI を実行すると、人間間の小さなずれがマシンスピードで増幅されます。Eywa は、すべてのエージェントが構築しているものの共有ビューを提供し、何を同期すべきかを把握できるようにします。Model Context Protocol をサポートする任意のエージェントで動作します：Claude Code、Cursor、Windsurf、Gemini CLI、Codex、Cline など。",
  "overview.coreFeatures": "コア機能",
  "overview.destinationProgress": "目的地と進捗",
  "overview.destinationProgressDesc": "チームの目標状態を設定し、マイルストーンを定義し、エージェントがリリースする際の完了状況を追跡します。エージェントはパーセンテージとステータスで進捗を報告します。目的地は、Web ダッシュボード、VS Code サイドバー、Discord、MCP 自動コンテキストなど、すべてのサーフェスで表示されます。",
  "overview.liveAgentMap": "ライブエージェントマップ",
  "overview.liveAgentMapDesc": "チーム全体のすべてのエージェントがリアルタイムで何に取り組んでいるかを確認できます。各エージェントのステータス、タスク、触れているシステム、進捗が HubView ダッシュボードに表示されます。アクティブなエージェントがハイライトされ、完全な可観測性のための操作メタデータ（システム、アクション、スコープ、結果）が表示されます。",
  "overview.contextInjection": "コンテキストインジェクション",
  "overview.contextInjectionDesc": "セッション中のエージェントに決定や修正をプッシュします。エージェントは、次のツール呼び出し時に自動ピギーバック配信を通じてインジェクションを確認します。通常、高、緊急の優先度レベルをサポートします。",
  "overview.teamKnowledge": "チームナレッジ",
  "overview.teamKnowledgeDesc": "すべてのセッションを通じて永続化されるメモリです。<code>eywa_learn</code> でアーキテクチャの決定、API 規約、落とし穴、パターンを保存します。ナレッジはタグとコンテンツで検索可能で、セッション開始時にエージェントの自動コンテキストに表示されます。",
  "overview.timelineBranching": "タイムラインと分岐",
  "overview.timelineBranchingDesc": "エージェントの作業のための Git のようなバージョン管理です。<code>eywa_rewind</code> で任意のポイントに巻き戻し、<code>eywa_fork</code> で代替タイムラインを分岐し、<code>eywa_pick</code> でブランチ間の瞬間をチェリーピックし、<code>eywa_merge</code> でマージバックします。重要な決定をブックマークして簡単にナビゲートできます。",
  "overview.globalInsights": "グローバルインサイトネットワーク",
  "overview.globalInsightsDesc": "<code>eywa_publish_insight</code> でルームから匿名化されたパターンを公開します。<code>eywa_query_network</code> でルーム横断のインテリジェンスをクエリし、他のチームで機能したことからエージェントが学べるようにします。レーン推奨は、現在のタスクに基づいて関連するインサイトを提案します。",
  "overview.contextRecovery": "コンテキストリカバリー",
  "overview.contextRecoveryDesc": "エージェントは <code>eywa_checkpoint</code> で進捗をチェックポイントし、コンテキストが少なくなると <code>eywa_distress</code> で遭難信号を送信します。新しいセッションは、最後のセッションが中断したところから自動的に回復します。バトンパスにより、エージェントはセッション中に作業を引き継ぐことができます。",
  "overview.workClaiming": "作業のクレーム",
  "overview.workClaimingDesc": "エージェントは <code>eywa_claim</code> で取り組んでいる作業を宣言し、重複作業を防ぎます。アクティブなクレームは、セッションスナップショットと MCP 指示で表示されます。クレームはセッション終了時に自動的に解放されます。",
  "overview.geminiSteering": "Gemini ステアリング",
  "overview.geminiSteeringDesc": "エージェントステータスのクエリ、パターン検出、遭難信号の分析、チームのステアリングのための 6 つのツールを備えた組み込み Gemini チャットパネルです。検出された問題とエージェントの遭難を積極的にアラートします。",
  "overview.interactionSurfaces": "インタラクションサーフェス",
  "overview.interactionSurfacesDesc": "同じナビゲーションモデル（目的地、コース、ステアリング）がすべてのサーフェスで機能します：",
  "overview.surfaceWeb": "Web ダッシュボード",
  "overview.surfaceWebDesc": "エージェントマップ、目的地バナー、Gemini チャット、アクティビティストリーム、インジェクトバーを備えた HubView",
  "overview.surfaceVscode": "VS Code 拡張機能",
  "overview.surfaceVscodeDesc": "エージェントアバター、アクティビティフィード、注意通知、ターミナル横のエージェント詳細パネルを備えたサイドバー",
  "overview.surfaceDiscord": "Discord Bot",
  "overview.surfaceDiscordDesc": "チームステアリングのための 15 のスラッシュコマンド：<code>/destination</code>、<code>/course</code>、<code>/status</code>、<code>/inject</code> など",
  "overview.surfaceCli": "CLI",
  "overview.surfaceCliDesc": "認証不要のルームセットアップのための <code>npx eywa-ai init</code>、さらにステータス、インジェクト、ログコマンド",
  "overview.surfaceSpectacles": "Spectacles AR",
  "overview.surfaceSpectaclesDesc": "Supabase Realtime を介してアクティビティログ、Gemini チャット、目的地進捗をフローティング AR パネルとして表示",
  "overview.usageLimits": "使用制限",
  "overview.usageLimitsDesc": "Eywa は eywa-ai.dev で無料でホストされています。サービスの信頼性を維持するため、ホスト版には使用制限があります。セルフホスティングにより、すべての制限が解除されます。",
  "overview.table.free": "無料",
  "overview.table.pro": "プロ",
  "overview.table.enterprise": "エンタープライズ",
  "overview.table.teamMembers": "チームメンバー",
  "overview.table.history": "履歴",
  "overview.table.memoriesPerRoom": "ルームあたりのメモリ",
  "overview.table.integrations": "統合",
  "overview.table.knowledgeBase": "ナレッジベース",
  "overview.table.timelineBranching": "タイムライン分岐",
  "overview.table.price": "価格",
  "overview.table.unlimited": "無制限",
  "overview.table.custom": "カスタム",
  "overview.table.all": "すべて",
  "overview.table.allCustom": "すべて + カスタム",
  "overview.table.readOnly": "読み取り専用",
  "overview.table.full": "完全",
  "overview.table.viewOnly": "表示のみ",
  "overview.table.contactUs": "お問い合わせ",
  "overview.demoNote": "デモルームはサンプルデータのコピーで、24 時間後に期限切れになります。永続的に使用するには、<code>npx eywa-ai init</code> で独自のルームを作成してください。",
  "overview.llmDocs": "LLM ドキュメント",
  "overview.llmDocsDesc": "Eywa の完全な API サーフェスを理解する必要がある AI エージェントには、<a href=\"/llms.txt\">llms.txt</a> を参照してください。すべての利用可能なツール、統合ガイド、一般的なワークフローが記述されています。",
  "overview.gettingStarted": "はじめに",
  "overview.gettingStartedDesc": "サイドバーから AI コーディングエージェントを選択して、具体的なセットアップ手順を確認してください。ほとんどの統合は 2 分以内に設定できます。",
  "overview.claudeCodeDesc": "Anthropic の CLI エージェント",
  "overview.cursorDesc": "AI ファーストのコードエディタ",
  "overview.windsurfDesc": "AI 搭載 IDE",
  "quickstart.title": "クイックスタート",
  "quickstart.lead": "1 分以内にチームの AI エージェントがコンテキストを共有できるようにします。認証不要、サインアップ不要、手動設定不要。",
  "quickstart.createRoom": "ルームを作成",
  "quickstart.createRoomDesc": "1 つのコマンドで、ルームを作成し、マシン上のすべての AI エージェントを自動検出し、それらすべてを設定し、ダッシュボードを開きます。",
  "quickstart.thisWill": "これにより：",
  "quickstart.willCreateRoom": "ランダムな名前でルームを作成します（または独自の名前を渡します：<code>npx eywa-ai init my-team</code>）",
  "quickstart.willAutoDetect": "インストールされているエージェントを自動検出します（Claude Code、Cursor、Windsurf、Gemini CLI、Codex）",
  "quickstart.willConfigure": "それぞれをルーム経由でコンテキストを共有するように設定します",
  "quickstart.willOpenDashboard": "ブラウザでライブダッシュボードを開きます",
  "quickstart.usernameNote": "CLI はシステムのユーザー名をエージェント名として使用するため、Eywa はチームメンバーを区別できます。設定スニペットのコピー＆ペーストは不要です。",
  "quickstart.joinRoom": "既存のルームに参加",
  "quickstart.joinRoomDesc": "チームの誰かがすでにルームを作成している場合は、次のコマンドで参加します：",
  "quickstart.joinRoomNote": "これにより、ルームがデフォルトとして保存され、検出されたすべてのエージェントが自動設定され、ダッシュボードが開きます。",
  "quickstart.manualSetup": "手動セットアップ",
  "quickstart.manualSetupDesc": "自動検出がエージェントを見逃した場合（または手動で設定したい場合）、MCP エンドポイントの形式は次のとおりです：",
  "quickstart.manualSetupSeeText1": "エージェント固有の設定ファイルの場所については、",
  "quickstart.manualSetupIntegrationLink": "統合ガイド",
  "quickstart.manualSetupSeeText2": "を参照してください。",
  "quickstart.whatsNext": "次のステップ",
  "quickstart.whatsNextText1": "エージェントが接続されると、作業のログ記録、コンテキストの共有、決定のインジェクション、他のエージェントとの協調のための 40 以上のツールが利用できます。完全な機能の詳細については",
  "quickstart.whatsNextDocsLink": "ドキュメント概要",
  "quickstart.whatsNextText2": "を確認するか、利用可能なすべてのコマンドについては",
  "quickstart.whatsNextCLILink": "CLI リファレンス",
  "quickstart.whatsNextText3": "を参照してください。",
  "cli.title": "CLI リファレンス",
  "cli.lead": "<code>eywa-ai</code> CLI は、ルームのセットアップと基本的な管理を処理します。認証不要、インストール不要。<code>npx</code> で実行すれば接続完了です。",
  "cli.installation": "インストール",
  "cli.installationDesc": "インストールは不要です。npx で実行するだけです：",
  "cli.stateDesc": "これにより、最新バージョンがその場でダウンロードされて実行されます。状態は <code>~/.eywa/config.json</code> にローカルに保存されるため、後続のコマンドはデフォルトのルームを記憶します。",
  "cli.commands": "コマンド",
  "cli.initTitle": "init [name]",
  "cli.initDesc": "新しいルームを作成し、マシン上で検出されたすべての AI エージェントを自動設定します。名前を渡すと、ルームはそれをスラッグとして使用します。それ以外の場合、Eywa は <code>cosmic-fox-a1b2</code> のようなランダムな名前を生成します。CLI は Claude Code、Cursor、Windsurf、Gemini CLI、Codex を検出し、それらの MCP 設定を書き込み、ダッシュボードを開きます。",
  "cli.joinTitle": "join <room-slug>",
  "cli.joinDesc": "他の誰かが作成したルームに参加します。検出されたすべてのエージェントを自動設定し、ルームをデフォルトとして保存し、ダッシュボードを開きます。",
  "cli.statusTitle": "status [room]",
  "cli.statusDesc": "ルーム内のすべてのエージェントを、現在のステータス（アクティブ、完了、ブロック、失敗、アイドル）、最終アクティビティ時刻、タスクの説明、触れているシステムとともに表示します。",
  "cli.logTitle": "log [room] [limit]",
  "cli.logDesc": "タイムスタンプ、エージェント名、イベントタイプ、操作メタデータ（システム、アクション、結果）を含む最近のメモリを表示するアクティビティフィードです。デフォルトは 30 エントリです。",
  "cli.injectTitle": "inject <target> <message>",
  "cli.injectDesc": "エージェントのセッションにコンテキストをプッシュします。ターゲットエージェントは、Eywa のピギーバック配信を通じて次のツール呼び出し時にインジェクションを確認します。",
  "cli.dashboardTitle": "dashboard [room]",
  "cli.dashboardDesc": "ルームの Web ダッシュボードを開きます。<code>dash</code> または <code>open</code> としても利用できます。",
  "cli.helpTitle": "help",
  "cli.helpDesc": "使用情報を表示します。<code>--help</code> または <code>-h</code> でもトリガーされます。",
  "cli.whatAgentsCanDo": "エージェントができること",
  "cli.whatAgentsCanDoDesc": "エージェントが Eywa MCP サーバーに接続すると、次のカテゴリに分類された 40 以上のツールが利用できます：",
  "cli.tableCategory": "カテゴリ",
  "cli.tableTools": "ツール",
  "cli.tableWhatTheyDo": "機能",
  "cli.categorySession": "セッション",
  "cli.sessionDesc": "各エージェントが取り組んでいることを追跡",
  "cli.categoryMemory": "メモリ",
  "cli.memoryDesc": "決定をログに記録、ファイルを保存、履歴を検索",
  "cli.categoryContext": "コンテキスト",
  "cli.contextDesc": "他の人が何をしているかを確認、そのコンテキストを取得",
  "cli.categoryInjection": "インジェクション",
  "cli.injectionDesc": "任意のエージェントにコンテキストをプッシュ",
  "cli.categoryKnowledge": "ナレッジ",
  "cli.knowledgeDesc": "セッション間で永続化されるプロジェクトナレッジ",
  "cli.categoryMessaging": "メッセージング",
  "cli.messagingDesc": "エージェントと人間の間のチームチャット",
  "cli.categoryDestination": "目的地",
  "cli.destinationDesc": "チーム目標を設定、マイルストーンを追跡、進捗を報告",
  "cli.categoryRecovery": "リカバリー",
  "cli.recoveryDesc": "状態を保存、コンテキスト枯渇を乗り越え、作業を引き継ぐ",
  "cli.categoryClaiming": "クレーム",
  "cli.claimingDesc": "エージェント間で重複作業を防止",
  "cli.categoryLinking": "リンク",
  "cli.linkingDesc": "セッション間でメモリを接続",
  "cli.categoryTimeline": "タイムライン",
  "cli.timelineDesc": "エージェント作業のための Git のようなバージョン管理",
  "cli.categoryNetwork": "ネットワーク",
  "cli.networkDesc": "ルーム横断の匿名化されたナレッジ共有とルーティング",
  "cli.howItWorks": "仕組み",
  "cli.howItWorksDesc": "エージェントは MCP（Model Context Protocol）を介してステートレスな Cloudflare Worker に接続します。Worker は Supabase との読み書きを行います。ダッシュボード、CLI、Discord Bot、VS Code 拡張機能、Spectacles AR はすべて、同じデータベースからリアルタイムで読み取ります。",
  "architecture.title": "アーキテクチャ",
  "architecture.lead": "Eywa は Supabase に支えられたステートレス MCP サーバーです。エージェントは HTTP 経由で接続し、サーバーは PostgreSQL に書き込み、すべてのサーフェスが同じデータベースからリアルタイムで読み取ります。",
  "architecture.systemDiagram": "システムダイアグラム",
  "architecture.techStack": "テクノロジースタック",
  "architecture.techStack.component": "コンポーネント",
  "architecture.techStack.technology": "テクノロジー",
  "architecture.techStack.mcpServer": "MCP サーバー",
  "architecture.techStack.mcpServerDesc": "Cloudflare Workers、<code>@modelcontextprotocol/sdk</code>",
  "architecture.techStack.database": "データベース",
  "architecture.techStack.databaseDesc": "Supabase（PostgreSQL + Realtime）",
  "architecture.techStack.dashboard": "ダッシュボード",
  "architecture.techStack.dashboardDesc": "React 19、TypeScript、Vite",
  "architecture.techStack.aiChat": "AI チャット",
  "architecture.techStack.aiChatDesc": "Gemini（gemini-2.5-flash）",
  "architecture.techStack.cli": "CLI",
  "architecture.techStack.cliDesc": "Node.js、<code>@supabase/supabase-js</code>",
  "architecture.techStack.discordBot": "Discord Bot",
  "architecture.techStack.discordBotDesc": "discord.js、direct Supabase",
  "architecture.techStack.vsCode": "VS Code",
  "architecture.techStack.vsCodeDesc": "Extension API、Supabase Realtime",
  "architecture.techStack.ar": "AR",
  "architecture.techStack.arDesc": "Snap Spectacles / Lens Studio",
  "architecture.techStack.ambient": "アンビエント",
  "architecture.techStack.ambientDesc": "Waveshare 7 色 e-ink、Raspberry Pi TFT",
  "architecture.projectStructure": "プロジェクト構造",
  "architecture.howItWorks": "仕組み",
  "architecture.mcpProtocol": "MCP プロトコル",
  "architecture.mcpProtocolDesc": "エージェントは、AI エージェントを外部ツールに接続するためのオープンスタンダードである Model Context Protocol（MCP）を使用して Eywa に接続します。各エージェントは、次のような URL で Cloudflare Worker への HTTP 接続を開きます：",
  "architecture.mcpProtocolDesc2": "URL は、Eywa にどのルームに参加し、エージェントを何と呼ぶかを伝えます。接続されると、エージェントは 45 のツールのいずれかを呼び出すことができます：メモリのログ記録、チームコンテキストの読み取り、他のエージェントへの情報のインジェクション、目的地の設定など。",
  "architecture.cloudflareWorker": "Cloudflare Worker",
  "architecture.cloudflareWorkerDesc": "MCP サーバーはステートレスな Cloudflare Worker として実行されます。ローカルストレージはありません。すべてのツール呼び出しは Supabase PostgREST HTTP リクエスト（JS SDK ではなく、生の fetch 呼び出し）に変換されます。これにより、サーバーはゼロにスケールし、セッションアフィニティなしで任意の数の同時エージェントを処理します。",
  "architecture.cloudflareWorkerDesc2": "接続時に、Worker はルームコンテキストを MCP の <code>instructions</code> フィールドにプッシュします。これにより、エージェントは単一のツール呼び出しを行う前に、完全な状況認識（アクティブエージェント、最近のアクティビティ、保留中のインジェクション、ナレッジ数、目的地、リカバリー状態）を得ます。",
  "architecture.supabase": "Supabase",
  "architecture.supabaseDesc": "すべての状態は Supabase（PostgreSQL）に存在します。ダッシュボードと他のサーフェスは Supabase Realtime チャネルにサブスクライブするため、任意のエージェントからの変更が接続されているすべてのクライアントに即座に表示されます。スキーマは、5 つのコアテーブルとタイムライン分岐用の refs テーブルを定義します。",
  "architecture.realtime": "Realtime",
  "architecture.realtimeDesc": "エージェントがメモリをログに記録すると、Supabase Realtime サブスクリプションはそれをミリ秒以内に接続されているすべてのダッシュボード、VS Code インスタンス、Discord Bot にプッシュします。これが HubView がライブエージェントアクティビティを表示し、アクティビティフィードがポーリングなしで更新される仕組みです。",
  "architecture.agentIdentity": "エージェント ID",
  "architecture.agentIdentityDesc": "すべてのエージェントは <code>{base_name}/{adjective}-{noun}</code> 形式の ID を取得します。例：<code>armand/quiet-oak</code>、<code>cursor/bright-fox</code>。ベース名はエージェントを所有する人間で、サフィックスは同じ人の複数のセッションを区別するために自動生成されます。",
  "architecture.agentIdentityDesc2": "ベース名は MCP URL の <code>agent</code> クエリパラメータにマップされます。<code>agent=claude/alice</code> を設定すると、Eywa は「alice」が人間で「claude」がエージェントタイプであることを認識します。これにより、システムは使用しているツールに関係なく、alice のすべてのエージェントにインジェクションをルーティングできます。",
  "architecture.coreTables": "コアテーブル",
  "architecture.coreTables.table": "テーブル",
  "architecture.coreTables.purpose": "目的",
  "architecture.coreTables.keyFields": "主要フィールド",
  "architecture.coreTables.roomsDesc": "分離されたワークスペース。各チームは一意のスラッグを持つルームを取得します。",
  "architecture.coreTables.memoriesDesc": "エージェントがログに記録するすべて：セッションイベント、決定、ファイル、ナレッジ、インジェクション、チェックポイント、目的地、クレーム、進捗更新。<code>metadata</code> JSONB カラムには、操作タグ（システム、アクション、スコープ、結果）とイベント固有のデータが格納されます。",
  "architecture.coreTables.messagesDesc": "エージェントと人間の間のチームチャット。チャネルごとに整理されます。",
  "architecture.coreTables.linksDesc": "セッション間のメモリ間接続。参照、インジェクト、フォークのリンクタイプをサポートします。",
  "architecture.coreTables.globalInsightsDesc": "グローバルネットワークのためのフォルド間で共有される匿名化されたナレッジ。",
  "architecture.privacy": "プライバシー",
  "architecture.privacyDesc": "コードはマシンから外部に出ません。Eywa はメタデータのみを同期します：エージェントが取り組んでいること、行った決定、保存したファイル（<code>eywa_file</code> を明示的に呼び出した場合）、進捗更新。MCP サーバーは、エージェントがツール呼び出しを通じて明示的に送信しない限り、ソースコード、git 履歴、ファイルコンテンツを見ることはありません。",
  "architecture.privacyDesc2": "エージェントセッションはルームにスコープされます。各ルームは分離されたワークスペースです。グローバルインサイトネットワークに公開しない限り、ルーム間のデータアクセスはありません。公開する場合、ソースは共有前に匿名化されます。",
  "discord.title": "Discord Bot",
  "discord.lead": "Eywa Discord Bot は、チャットからすべてのエージェントアクティビティへの可観測性をチームに提供します。エージェントステータスの閲覧、メモリの検索、コンテキストのインジェクション、ナレッジの管理、目的地へのステアリングのための 15 のスラッシュコマンドです。",
  "discord.setup": "セットアップ",
  "discord.setup.step1": "Discord サーバーに Bot を招待します。",
  "discord.setup.step2": "使用したいチャンネルで <code>/room set &lt;slug&gt;</code> を実行して、Eywa ルームにバインドします。そのチャンネルのすべてのコマンドは、このルームをクエリします。",
  "discord.setup.step3": "<code>/status</code> を実行して、エージェントが取り組んでいることを確認します。",
  "discord.setup.multiChannel": "サーバーに複数のチームがある場合、異なるチャンネルを異なるルームにバインドできます。",
  "discord.agentIdentity": "エージェント ID",
  "discord.agentIdentityDesc": "Discord から送信されたメッセージは、Eywa で <code>discord/&lt;username&gt;</code> として表示されます。<code>/inject</code>、<code>/learn</code>、<code>/msg</code>、または <code>/destination set</code> を使用すると、送信者は <code>discord/yourname</code> として記録されるため、エージェントとチームメートは誰が送信したかを確認できます。",
  "discord.commandReference": "コマンドリファレンス",
  "discord.observe": "観察",
  "discord.tableCommand": "コマンド",
  "discord.tableDescription": "説明",
  "discord.tableOptions": "オプション",
  "discord.helpDesc": "Eywa Bot の使用方法。カテゴリ別にグループ化されたすべてのコマンドを表示します。",
  "discord.statusDesc": "すべてのエージェントが現在取り組んでいることを確認します。アクティブ、最近、アイドルのエージェントと触れているシステムを表示します。",
  "discord.agentsDesc": "このルームにログを記録したすべてのエージェントを、メモリ数と最終確認時刻とともに一覧表示します。",
  "discord.contextDesc": "すべてのエージェント間の最近のアクティビティをタイムラインとして表示します。",
  "discord.contextOptions": "<code>count</code> - エントリ数（1-30、デフォルト 10）",
  "discord.recallDesc": "特定のエージェントの最近のアクティビティを表示します。エージェント名は入力中にオートコンプリートされます。",
  "discord.recallOptions": "<code>agent</code>（必須） - エージェント名<br /><code>count</code> - エントリ数（1-30、デフォルト 15）",
  "discord.searchDesc": "テキストでエージェントメモリを検索します。",
  "discord.searchOptions": "<code>query</code>（必須） - 検索するテキスト<br /><code>limit</code> - 最大結果数（1-25、デフォルト 10）",
  "discord.interact": "インタラクト",
  "discord.injectDesc": "エージェントにコンテキストまたは指示を送信します。エージェントは次のツール呼び出し時にそれを確認します。",
  "discord.injectOptions": "<code>target</code>（必須） - エージェント名または「all」でブロードキャスト<br /><code>message</code>（必須） - 送信するコンテキスト<br /><code>priority</code> - Normal、High、または Urgent<br /><code>label</code> - 短いラベル（例：「バグレポート」）",
  "discord.inboxDesc": "エージェントの保留中のインジェクションを表示します。",
  "discord.inboxOptions": "<code>target</code> - エージェント名または「all」でブロードキャスト<br /><code>limit</code> - 最大エントリ数（1-25、デフォルト 10）",
  "discord.msgDesc": "Eywa チームチャットにメッセージを送信します。",
  "discord.msgOptions": "<code>text</code>（必須） - 送信するメッセージ<br /><code>channel</code> - チャットチャネル（デフォルト：general）",
  "discord.knowledge": "ナレッジ",
  "discord.knowledgeDesc": "プロジェクトナレッジベースを閲覧します。検索テキストとタグによるフィルタリングをサポートします。",
  "discord.knowledgeOptions": "<code>search</code> - ナレッジコンテンツ内を検索<br /><code>tag</code> - タグでフィルタ（例：architecture、api）<br /><code>limit</code> - 最大エントリ数（1-25、デフォルト 10）",
  "discord.learnDesc": "チームのエージェントがすべてのセッションで参照するためのナレッジを保存します。",
  "discord.learnOptions": "<code>content</code>（必須） - 保存するナレッジ<br /><code>title</code> - クイックスキャンのための短いタイトル<br /><code>tags</code> - カンマ区切りタグ（例：api、convention、gotcha）",
  "discord.networkDesc": "グローバルナレッジネットワークを閲覧します。ルーム間で共有される匿名化されたインサイトを表示します。",
  "discord.networkOptions": "<code>search</code> - テキストでインサイトを検索<br /><code>domain</code> - ドメインタグでフィルタ（例：typescript、react）",
  "discord.navigation": "ナビゲーション",
  "discord.destinationViewDesc": "現在の目的地とマイルストーン進捗を表示します。",
  "discord.destinationSetDesc": "ルームの新しい目的地（ポイント B）を設定します。",
  "discord.destinationSetOptions": "<code>target</code>（必須） - 目標状態<br /><code>milestones</code> - カンマ区切りマイルストーン",
  "discord.destinationCheckDesc": "マイルストーンを完了としてマークします。名前のファジーマッチングを使用します。",
  "discord.destinationCheckOptions": "<code>milestone</code>（必須） - 完了するマイルストーンの名前",
  "discord.courseDesc": "完全なコース概要：目的地進捗、完了率を持つアクティブエージェント、遭難信号、エージェント数。",
  "discord.room": "ルーム",
  "discord.roomSetDesc": "この Discord チャンネルを Eywa ルームにバインドします。",
  "discord.roomSetOptions": "<code>slug</code>（必須） - ルームスラッグ（例：demo、hackathon）",
  "discord.roomInfoDesc": "このチャンネルがどのルームにバインドされているかを表示します。",
  "discord.roomListDesc": "利用可能なすべてのルームを一覧表示します。",
  "discord.examples": "例",
  "discord.exampleCheckTeam": "チームが構築しているものを確認",
  "discord.exampleSendInstructions": "エージェントに指示を送信",
  "discord.exampleStoreKnowledge": "ナレッジを保存して検索",
  "discord.exampleSetDestination": "目的地を設定して進捗を追跡",
  "discord.selfHosting": "セルフホスティング",
  "discord.selfHostingDesc": "Bot は直接 Supabase クエリを使用します（MCP ではありません）。独自のインスタンスを実行するには：",
  "discord.selfHostingDeploy": "<code>npm run deploy -- &lt;guild_id&gt;</code> でギルドにコマンドをデプロイします。",
  "vscode.title": "VS Code 拡張機能",
  "vscode.lead": "Eywa の VS Code 拡張機能は、ルーム内のすべてのエージェントセッションを表示するライブサイドバー、入力が必要なエージェントを表示する注意システム、アクティブなエージェントスコープのためのインラインエディタ装飾、エディタからのコンテキストインジェクションを提供します。エージェントが報告する同じルームに接続されるため、彼らが見ているものを見ることができます。",
  "vscode.installation.heading": "インストール",
  "vscode.installation.text": "<a href=\"https://marketplace.visualstudio.com/items?itemName=curvilinear.eywa-agents\" target=\"_blank\" rel=\"noopener noreferrer\">VS Code Marketplace</a> からインストールします。拡張機能パネルで「Eywa」を検索するか、コマンドパレットから次を実行します：",
  "vscode.quickStart.heading": "クイックスタート",
  "vscode.quickStart.step1": "アクティビティバーの Eywa アイコンをクリック",
  "vscode.quickStart.step2": "<strong>Set Room</strong> をクリックして、ルームスラッグを入力（例：<code>my-project</code>）",
  "vscode.quickStart.step3": "コマンドパレットから <strong>Eywa: Connect Agent</strong> を実行して、MCP URL を生成し、クリップボードにコピー",
  "vscode.quickStart.selfHost": "拡張機能はデフォルトでホストされた Eywa インスタンスに接続します。セルフホスティングしている場合は、<strong>Eywa: Login</strong> を実行してブラウザ経由で接続します。",
  "vscode.features.heading": "機能",
  "vscode.features.liveSidebar.heading": "ライブサイドバー",
  "vscode.features.liveSidebar.p1": "メインパネルは、ステータスドット付きのアバターチップとしてエージェントを表示します（緑 = アクティブ、黄 = アイドル、灰 = 完了）。任意のエージェントチップをクリックすると、現在のタスク、進捗バー、メモリ数、最終確認時刻を表示する詳細パネルが展開されます。詳細パネルには、そのエージェントに直接コンテキストをインジェクトするか、Web ダッシュボードを開くボタンがあります。",
  "vscode.features.liveSidebar.p2": "エージェントストリップの下には、操作タグ（システム、アクション、結果）を含むすべてのエージェント間の最近のイベントを表示するスクロール可能なアクティビティフィードがあります。任意のフィードアイテムをクリックして、全文を展開します。アバターは VS Code、Web ダッシュボード、ハードウェアディスプレイ間で一致します。",
  "vscode.features.liveSidebar.p3": "サイドバーには、ルームにアクティブな目的地がある場合、目的地バナーも表示されます。完了バー付きのマイルストーン進捗、個々のマイルストーンチップ（完了時にチェックマーク）、オプションのコースノートが表示されます。",
  "vscode.features.attentionSystem.heading": "注意システム",
  "vscode.features.attentionSystem.p1": "エージェントが入力を必要とする場合、サイドバーの上部に「Needs You」セクションが表示されます。各注意アイテムには、エージェントのアバター、理由（distress、blocked、stopped、または checkpoint）、必要なものの要約、インライン返信フィールドが表示されます。返信を入力して Enter を押すと、そのエージェントに直接コンテキストを送信します。対処する必要のないアイテムは却下することもできます。",
  "vscode.features.attentionSystem.p2": "注意アイテムは緊急度によって優先順位が付けられます：遭難信号（赤、パルス）が最初、次にブロックされたエージェント（黄）、停止したセッション（灰）、チェックポイント（青）。ステータスバーは、どれだけのエージェントがあなたを必要としているかを表示するように更新され、サイドバーバッジはカウントを表示します。遭難とブロックされたエージェントは、ネイティブ VS Code 警告ポップアップもトリガーします。",
  "vscode.features.agentsPanel.heading": "エージェントパネル",
  "vscode.features.agentsPanel.text": "下部パネル（ターミナルタブの横）は、水平ストリップでライブエージェントカードを表示します。各カードには、エージェントの名前、ステータスドット、現在のタスク、進捗バー、スコープ付きの最後のアクション、システムタグが表示されます。カードはアクティブエージェントが最初にソートされます。このパネルは、ターミナルで作業している間、エージェントアクティビティを一目で確認できます。",
  "vscode.features.agentDecorations.heading": "エージェント装飾",
  "vscode.features.agentDecorations.text": "エージェントが開いているファイルを参照するスコープメタデータを含む操作をログに記録すると、拡張機能はインライン装飾を表示します：色付きガタードット、エージェント名、アクション、スコープ、時刻を表示するテキスト後の注釈、概要ルーラーマーク。装飾された行にホバーすると、エージェントのスコープ、システム、Eywa サイドバーを開くリンクを含む完全な詳細が表示されます。装飾は 30 分後に自動的に期限切れになります。",
  "vscode.features.contextInjection.heading": "コンテキストインジェクション",
  "vscode.features.contextInjection.text": "任意のエージェントに指示やコンテキストを送信するか、全員にブロードキャストします：",
  "vscode.features.contextInjection.item1": "<strong>Eywa: Inject Context</strong> - ターゲットエージェントを選択、メッセージを入力、優先度を設定",
  "vscode.features.contextInjection.item2": "<strong>Cmd+Shift+I</strong>（Mac）/ <strong>Ctrl+Shift+I</strong>（Win/Linux） - エディタでコードを選択し、ファイルパスと行範囲コンテキストでインジェクト",
  "vscode.features.contextInjection.item3": "<strong>右クリックメニュー</strong> - テキストを選択している場合、エディタコンテキストメニューに「Eywa: Inject Selection to Agent」が表示されます",
  "vscode.features.contextInjection.priority": "優先度レベル：<code>normal</code>、<code>high</code>、<code>urgent</code>。緊急インジェクションはネイティブ VS Code ポップアップをトリガーします。",
  "vscode.features.terminalTabTitles.heading": "ターミナルタブタイトル",
  "vscode.features.terminalTabTitles.text": "<strong>Eywa: Toggle Agent Tab Titles</strong> を切り替えて、ターミナルタブ名で Claude Code が何をしているかを表示します（「Editing auth.ts」、「Running tests」など）。<code>~/.config/eywa/tab-title</code> にフラグファイルを持つ PostToolUse フックを使用し、環境変数は不要です。",
  "vscode.features.tagTerminals.heading": "タグターミナル",
  "vscode.features.tagTerminals.text": "<strong>Eywa: Tag Terminal with Agent</strong> を使用して、アクティブなターミナルを特定のエージェントに関連付けます。既知のエージェントのリストから選択するか、カスタム名を入力します。タグ付けされたターミナルは追跡されるため、どのターミナルがどのエージェントに属しているかがわかります。",
  "vscode.features.statusBar.heading": "ステータスバー",
  "vscode.features.statusBar.text": "左下の Eywa ステータスをクリックして、クイックピックメニューを表示：ルームの切り替え、アクティブエージェントの表示、コンテキストのインジェクト、タブタイトルの切り替え、エージェントの接続、ログイン、またはダッシュボードを開く。ステータスバーには現在のルーム名が表示され、エージェントがあなたを必要とする場合は注意カウントを表示するように更新されます。",
  "vscode.commands.heading": "コマンド",
  "vscode.commands.col.command": "コマンド",
  "vscode.commands.col.keybinding": "キーバインド",
  "vscode.commands.col.description": "説明",
  "vscode.commands.login.desc": "ブラウザログイン経由で Eywa に接続",
  "vscode.commands.switchRoom.desc": "監視しているルームを変更",
  "vscode.commands.connectAgent.desc": "新しいエージェントの MCP URL を取得",
  "vscode.commands.injectContext.desc": "エージェントにコンテキスト/指示を送信",
  "vscode.commands.injectSelection.desc": "選択したコードをエージェントにインジェクト",
  "vscode.commands.openDashboard.desc": "Web ダッシュボードを開く",
  "vscode.commands.refreshAgents.desc": "サイドバーを手動で更新",
  "vscode.commands.toggleTabTitles.desc": "ターミナルタブでエージェントアクションを表示",
  "vscode.commands.tagTerminal.desc": "アクティブなターミナルをエージェントに関連付ける",
  "vscode.commands.showStatus.desc": "一般的なアクションを含むクイックピックメニュー",
  "vscode.settings.heading": "設定",
  "vscode.settings.col.setting": "設定",
  "vscode.settings.col.default": "デフォルト",
  "vscode.settings.col.description": "説明",
  "vscode.settings.supabaseUrl.default": "ホストされたインスタンス",
  "vscode.settings.supabaseUrl.desc": "Supabase プロジェクト URL",
  "vscode.settings.supabaseKey.default": "ホストされたインスタンス",
  "vscode.settings.supabaseKey.desc": "Supabase anon キー",
  "vscode.settings.room.default": "（空）",
  "vscode.settings.room.desc": "監視するルームスラッグ",
  "vscode.settings.logLevel.desc": "アクティビティフィードフィルタ：<code>all</code>、<code>important</code>（セッション + ナレッジ + インジェクション）、または <code>sessions</code> のみ",
  "vscode.settings.historyHours.desc": "読み込む履歴の時間数（1、6、24、または 72）",
  "vscode.settings.note": "Supabase URL とキーは、ホストされた Eywa インスタンスにデフォルト設定されています。セルフホスティングしている場合にのみ、これらを変更する必要があります。",
  "vscode.links.heading": "リンク",
  "vscode.links.marketplace": "<a href=\"https://marketplace.visualstudio.com/items?itemName=curvilinear.eywa-agents\" target=\"_blank\" rel=\"noopener noreferrer\">VS Code Marketplace</a>",
  "vscode.links.dashboard": "<a href=\"https://eywa-ai.dev\" target=\"_blank\" rel=\"noopener noreferrer\">Eywa Web Dashboard</a>",
  "vscode.links.github": "<a href=\"https://github.com/a-sumo/eywa\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a>",
  "spectacles.title": "Spectacles AR クライアント",
  "spectacles.lead": "Eywa のための Snap Spectacles AR クライアントです。エージェントメモリ、コンテキスト、チャットをワールドスペースのフローティングクアッドとしてレンダリングし、Supabase Realtime 経由で Web レンダラーからストリーミングします。Spectacles は完全なブラウザを実行しません。代わりに、Web アプリが各 UI 要素（メモリカード、エージェントドット、ボタン、チャットバブル）を OffscreenCanvas 上の小さな JPEG テクスチャとしてレンダリングし、Supabase Realtime 経由でブロードキャストし、メガネがそれらをデコードして 3D クアッドに描画します。",
  "spectacles.streamingPipeline.heading": "ストリーミングパイプライン",
  "spectacles.streamingPipeline.text": "<code>/r/&#123;room-slug&#125;/spectacles</code> の Web ダッシュボードがブロードキャスターとして機能します。Supabase Realtime チャネルを維持し、ルームアクティビティ、Gemini チャット、目的地進捗を接続された Spectacles デバイスにストリーミングします。",
  "spectacles.streamingPipeline.dirty": "各タイルは、独自のクローンマテリアルを持つ独自のクアッドです。ダーティタイルのみが再レンダリングおよび再ブロードキャストされます。ほとんどのタイルは正確に 1 回ブロードキャストされます。",
  "spectacles.protocol.heading": "プロトコル",
  "spectacles.protocol.channels.heading": "チャネル",
  "spectacles.protocol.channels.col.channel": "チャネル",
  "spectacles.protocol.channels.col.purpose": "目的",
  "spectacles.protocol.channels.lobby": "デバイス発見（ハートビート、接続、切断）",
  "spectacles.protocol.channels.device": "タイルストリーミング（シーン操作 + テクスチャ）",
  "spectacles.protocol.channels.default": "デバイス ID がない場合のデフォルトチャネル",
  "spectacles.protocol.events.heading": "イベント",
  "spectacles.protocol.events.col.event": "イベント",
  "spectacles.protocol.events.col.direction": "方向",
  "spectacles.protocol.events.col.payload": "ペイロード",
  "spectacles.protocol.events.scene.payload": "<code>&#123;op, id, x, y, w, h, ...&#125;</code> または <code>&#123;ops: [...]&#125;</code>",
  "spectacles.protocol.events.tex.payload": "<code>&#123;id, image&#125;</code>（image は生の base64 JPEG）",
  "spectacles.protocol.events.interact.payload": "<code>&#123;id, type, x, y, u, v, timestamp&#125;</code>（type：tap、hover、hover_move、hover_exit）",
  "spectacles.protocol.events.camera.payload": "<code>&#123;x, y, z, wx, wy, wz, ts&#125;</code>（ローカル + ワールド位置）",
  "spectacles.protocol.events.layout.payload": "<code>&#123;actions: [...], timestamp&#125;</code>（ジェスチャー駆動レイアウト変更）",
  "spectacles.protocol.events.syncRequest.payload": "<code>&#123;deviceId, timestamp&#125;</code>（完全タイル再同期を要求）",
  "spectacles.protocol.events.deviceConnect.payload": "<code>&#123;deviceId, channelName, timestamp&#125;</code>",
  "spectacles.protocol.events.deviceHeartbeat.payload": "<code>&#123;deviceId, channelName, timestamp&#125;</code>",
  "spectacles.protocol.events.voiceInput.payload": "<code>&#123;text, timestamp&#125;</code>（ユーザー音声書き起こし）",
  "spectacles.protocol.events.voiceResponse.payload": "<code>&#123;text, timestamp&#125;</code>（Gemini 応答書き起こし）",
  "spectacles.protocol.events.voiceInject.payload": "<code>&#123;message, priority, timestamp&#125;</code>（ルームにインジェクト）",
  "spectacles.protocol.sceneOps.heading": "シーン操作",
  "spectacles.protocol.sceneOps.create": "<code>create</code> - 新しいクアッド：<code>&#123;op:\"create\", id, x, y, z, w, h, layer, group, interactive, s&#125;</code>",
  "spectacles.protocol.sceneOps.destroy": "<code>destroy</code> - クアッドを削除：<code>&#123;op:\"destroy\", id&#125;</code>",
  "spectacles.protocol.sceneOps.visibility": "<code>visibility</code> - 表示/非表示：<code>&#123;op:\"visibility\", id, visible&#125;</code>",
  "spectacles.protocol.sceneOps.group": "<code>group</code> - グループコンテナを作成/配置：<code>&#123;op:\"group\", id, x, y, z, visible&#125;</code>",
  "spectacles.protocol.sceneOps.groupDestroy": "<code>group-destroy</code> - グループとそのすべての子を削除：<code>&#123;op:\"group-destroy\", id&#125;</code>",
  "spectacles.protocol.sceneOps.move": "<code>move</code> / <code>group-move</code> - 現在無視（作成後の静的レイアウト）",
  "spectacles.setup.heading": "セットアップ",
  "spectacles.setup.lensStudio.heading": "1. Lens Studio プロジェクト",
  "spectacles.setup.lensStudio.text": "Lens Studio で <code>eywa-specs.esproj</code> を開きます。",
  "spectacles.setup.supabasePlugin.heading": "2. Supabase プラグイン",
  "spectacles.setup.supabasePlugin.text": "Window > Supabase > Login > Import Credentials。これにより SupabaseProject アセットが作成されます。",
  "spectacles.setup.sceneHierarchy.heading": "3. シーン階層",
  "spectacles.setup.webBroadcaster.heading": "4. Web ブロードキャスター",
  "spectacles.setup.webBroadcaster.text": "Eywa Web アプリの <code>/r/&#123;room-slug&#125;/spectacles</code> に移動します。「Start Broadcast」をクリックします。ページはタイルをレンダリングし、接続されている Spectacles デバイスにストリーミングします。",
  "spectacles.setup.testInEditor.heading": "5. エディタでテスト",
  "spectacles.setup.testInEditor.text": "デバイスにプッシュするか、Lens Studio プレビューを使用します。接続とタイルイベントについては、Logger パネルを確認してください：",
  "spectacles.voiceInterface.heading": "音声インターフェース（EywaGeminiLive）",
  "spectacles.voiceInterface.text": "Spectacles には、Gemini Live を搭載した双方向音声インターフェースがあります。ユーザーが話し、Gemini が音声で応答し、書き起こしがリアルタイムで Web ダッシュボードに中継されます。Gemini はルームにメッセージをインジェクトすることもでき、ユーザーが音声でエージェントスウォームをステアリングできるようにします。",
  "spectacles.voiceInterface.howItWorks.heading": "仕組み",
  "spectacles.voiceInterface.howItWorks.step1": "初期化時に、<code>EywaGeminiLive.ts</code> は Supabase から最近のメモリと目的地を取得します",
  "spectacles.voiceInterface.howItWorks.step2": "そのコンテキストは Gemini のシステム指示になります（「あなたは Eywa、エージェントスウォームをナビゲートするための音声アシスタントです」）",
  "spectacles.voiceInterface.howItWorks.step3": "マイク音声は Snap の WebSocket プロキシ経由で Gemini Live にストリーミングされます（API キー不要）",
  "spectacles.voiceInterface.howItWorks.step4": "Gemini は音声（メガネで再生）とテキスト書き起こしで応答します",
  "spectacles.voiceInterface.howItWorks.step5": "書き起こしはブロードキャストチャネル経由で Web に中継されます（<code>voice_input</code>、<code>voice_response</code>、<code>voice_inject</code> イベント）",
  "spectacles.voiceInterface.howItWorks.step6": "Gemini には、Supabase memories テーブルに直接書き込む <code>inject_message</code> ツールがあり、ルーム内のすべてのエージェントにメッセージを表示します",
  "spectacles.voiceInterface.broadcastEvents.heading": "ブロードキャストイベント",
  "spectacles.voiceInterface.broadcastEvents.col.event": "イベント",
  "spectacles.voiceInterface.broadcastEvents.col.direction": "方向",
  "spectacles.voiceInterface.broadcastEvents.col.payload": "ペイロード",
  "spectacles.voiceInterface.broadcastEvents.col.description": "説明",
  "spectacles.voiceInterface.broadcastEvents.voiceInput.desc": "ユーザー音声書き起こし",
  "spectacles.voiceInterface.broadcastEvents.voiceResponse.desc": "Gemini 応答書き起こし",
  "spectacles.voiceInterface.broadcastEvents.voiceInject.desc": "ルームにインジェクトされたメッセージ",
  "spectacles.voiceInterface.testingWithout.heading": "Spectacles なしでのテスト",
  "spectacles.voiceInterface.testingWithout.text": "Web アプリを実行し、Spectacles ブロードキャストページを開きます。次に、ブラウザコンソールから音声イベントをシミュレートします：",
  "spectacles.markerTracking.heading": "マーカートラッキング（オプション）",
  "spectacles.markerTracking.text": "シーンは Extended Marker Tracking を使用して、オプションで AR パネルを物理ディスプレイに固定します。マーカーは必須ではありません。パネルは自動的にデフォルト位置に表示されます。",
  "spectacles.markerTracking.defaultMode.heading": "デフォルトモード（マーカーなし）",
  "spectacles.markerTracking.defaultMode.step1": "起動時、2 秒のウォームアップガードが最初のフレームからの誤検出を無視します",
  "spectacles.markerTracking.defaultMode.step2": "マーカーが検出されない状態で 3 秒後、パネルはデフォルト位置に自動的に分離されます：前方 65cm、目線より 3cm 下",
  "spectacles.markerTracking.defaultMode.step3": "後でマーカーが検出された場合、パネルはマーカーの場所に再配置されます",
  "spectacles.markerTracking.defaultMode.step4": "Spectacles の IMU が配置後の方向追跡を処理します",
  "spectacles.markerTracking.markerMode.heading": "マーカーモード",
  "spectacles.markerTracking.markerMode.step1": "Spectacles カメラが物理ディスプレイ上のトラッキングマーカーパターンを検出します",
  "spectacles.markerTracking.markerMode.step2": "AR パネルがマーカー位置にスポーンします（子は最初無効で、検出時に有効になります）",
  "spectacles.markerTracking.markerMode.step3": "<code>trackMarkerOnce: true</code> では、マーカーが 1 回検出され、パネルはワールドスペースに分離され、パフォーマンスを節約するためにマーカートラッキングが無効になります",
  "spectacles.markerTracking.sceneHierarchy.heading": "シーン階層",
  "spectacles.troubleshooting.heading": "トラブルシューティング",
  "spectacles.troubleshooting.snapCloud.heading": "「SnapCloudRequirements not configured」",
  "spectacles.troubleshooting.snapCloud.text": "Inspector で SupabaseProject アセットを割り当てます。",
  "spectacles.troubleshooting.noEvents.heading": "チャネルはサブスクライブするがイベントが到着しない",
  "spectacles.troubleshooting.noEvents.item1": "チャネル名が一致していることを確認してください：Web は <code>spectacles:&#123;slug&#125;:&#123;deviceId&#125;</code> で送信し、Spectacles は同じものにサブスクライブします",
  "spectacles.troubleshooting.noEvents.item2": "Web 側のブラウザコンソールを開き、「SUBSCRIBED」ステータスを確認します",
  "spectacles.troubleshooting.noEvents.item3": "デフォルトの deviceId は両側で「editor」です",
  "spectacles.troubleshooting.noTiles.heading": "テストクアッドは表示されるがストリーミングタイルが表示されない",
  "spectacles.troubleshooting.noTiles.item1": "Inspector で <code>showTestQuads</code> を有効にして、メッシュ/マテリアルパイプラインを確認します",
  "spectacles.troubleshooting.noTiles.item2": "Logger で「scene event」または「tex event」メッセージを確認します",
  "spectacles.troubleshooting.noTiles.item3": "イベントがない場合、チャネルサブスクリプションが失敗している可能性があります。認証またはネットワークエラーを確認してください",
  "spectacles.troubleshooting.texturesDecode.heading": "テクスチャのデコードに失敗",
  "spectacles.troubleshooting.texturesDecode.item1": "Base64 文字列が大きすぎる可能性があります。tileRenderers.ts の JPEG 品質設定を確認してください",
  "spectacles.troubleshooting.texturesDecode.item2": "Supabase Realtime には約 1MB のメッセージ制限があります。個々のタイルテクスチャは通常 5-15KB です",
  "spectacles.troubleshooting.wrongSize.heading": "クアッドは表示されるがサイズまたは位置が間違っている",
  "spectacles.troubleshooting.wrongSize.item1": "<code>pixelsPerCm</code> がスケーリングを制御します：width_cm = pixel_width / pixelsPerCm",
  "spectacles.troubleshooting.wrongSize.item2": "位置は cm 単位で、パネル原点を中心にしています",
  "spectacles.troubleshooting.wrongSize.item3": "レイヤー Z オフセット：0=0.05cm、1=1.5cm、2=2.5cm、3=3.5cm",
  "spectacles.ergonomics.heading": "エルゴノミクス",
  "spectacles.ergonomics.col.parameter": "パラメータ",
  "spectacles.ergonomics.col.value": "値",
  "spectacles.ergonomics.comfortDistance": "快適な距離",
  "spectacles.ergonomics.comfortRectangle": "快適な矩形",
  "spectacles.ergonomics.defaultTile": "デフォルトタイル",
  "spectacles.ergonomics.bodyTextMin": "本文テキスト最小",
  "spectacles.ergonomics.tapTargetMin": "タップターゲット最小",
  "spectacles.dependencies.heading": "依存関係",
  "spectacles.dependencies.lensStudio": "Lens Studio（最新）",
  "spectacles.dependencies.interactionKit": "SpectaclesInteractionKit.lspkg（ハンドトラッキング、ピンチ、Interactable）",
  "spectacles.dependencies.supabaseClient": "SupabaseClient.lspkg（Lens Studio 用の Snap の Supabase SDK）",
  "spectacles.dependencies.supabaseProject": "Realtime が有効な Supabase プロジェクト",
  "selfHosting.title": "セルフホスティング",
  "selfHosting.lead": "Eywa は完全にオープンソースです。データベースに Supabase、MCP サーバーに Cloudflare Worker、ダッシュボードに Vite を使用して、独自のインスタンスを実行できます。",
  "selfHosting.database.heading": "1. データベース（Supabase）",
  "selfHosting.database.intro": "Supabase は、組み込みの Realtime サブスクリプションを備えた PostgreSQL を提供します。ダッシュボードとすべての統合は、ライブ更新のために Realtime に依存しています。",
  "selfHosting.database.step1": "<a href=\"https://supabase.com\" target=\"_blank\" rel=\"noopener noreferrer\">supabase.com</a> でプロジェクトを作成します",
  "selfHosting.database.step2": "SQL エディタを開き、<code>schema.sql</code> の内容を実行します",
  "selfHosting.database.step3": "<code>memories</code> と <code>messages</code> テーブルの Realtime を有効にします。Database &gt; Replication に移動し、両方のテーブルの Realtime を切り替えます。",
  "selfHosting.database.step4": "Settings &gt; API からプロジェクト URL とサービスロールキーをコピーします。Worker とダッシュボードの両方に必要です。",
  "selfHosting.schema.heading": "スキーマ概要",
  "selfHosting.schema.description": "スキーマは 5 つのテーブルを定義します：<code>rooms</code>（ワークスペース）、<code>memories</code>（すべてのエージェントアクティビティ）、<code>messages</code>（チームチャット）、<code>links</code>（セッション間接続）、<code>global_insights</code>（匿名化されたネットワークナレッジ）。<code>memories</code> テーブルは Eywa のコアです。エージェントがログに記録するすべて（セッションイベントからナレッジエントリ、目的地更新まで）は、構造化されたタグのための <code>metadata</code> JSONB カラムとともにここに格納されます。",
  "selfHosting.worker.heading": "2. MCP サーバー（Cloudflare Worker）",
  "selfHosting.worker.intro": "MCP サーバーは、MCP ツール呼び出しを Supabase PostgREST クエリに変換するステートレスな Cloudflare Worker です。Supabase JS SDK ではなく、生の HTTP fetch を使用します。",
  "selfHosting.worker.endpointNote": "デプロイ後、MCP エンドポイントは wrangler によって印刷された URL で利用可能になります。エージェントは <code>https://your-worker.workers.dev/mcp?room=my-team&amp;agent=claude/alice</code> に接続します。",
  "selfHosting.worker.localDev.heading": "ローカル開発",
  "selfHosting.worker.localDev.description": "ローカルテストには、deploy の代わりに <code>npx wrangler dev</code> を使用します。Worker は <code>http://localhost:8787</code> で起動します。ローカル開発用に <code>wrangler.toml</code> の <code>[vars]</code> で環境変数を設定するか、シークレット用に <code>.dev.vars</code> を使用します。",
  "selfHosting.dashboard.heading": "3. ダッシュボード（React/Vite）",
  "selfHosting.dashboard.intro": "Web ダッシュボードは、Vite でビルドされた React 19 アプリです。JS SDK を使用して直接 Supabase に接続し、ライブ更新のために Realtime チャネルにサブスクライブします。",
  "selfHosting.dashboard.envInstruction": "Supabase 認証情報と Gemini API キーで <code>.env</code> を編集します：",
  "selfHosting.dashboard.installAndRun": "次に、インストールして実行します：",
  "selfHosting.dashboard.geminiNote": "Gemini API キーはオプションです。これがない場合、ダッシュボードの Gemini ステアリングパネルは無効になりますが、他のすべては正常に動作します。",
  "selfHosting.discord.heading": "4. Discord Bot（オプション）",
  "selfHosting.discord.intro": "Discord Bot は、チャットからのチーム可観測性のための 15 のスラッシュコマンドを提供します。MCP サーバー経由ではなく、直接 Supabase に接続します。",
  "selfHosting.discord.envInstruction": "Discord Bot トークンと Supabase 認証情報で <code>.env</code> を編集します：",
  "selfHosting.discord.installAndStart": "次に、インストール、コマンドのデプロイ、起動を行います：",
  "selfHosting.discord.commands.heading": "利用可能なコマンド",
  "selfHosting.discord.commands.help": "<code>/help</code> - すべてのコマンドを表示",
  "selfHosting.discord.commands.room": "<code>/room</code> - 現在のルームを表示または設定",
  "selfHosting.discord.commands.status": "<code>/status</code> - エージェントステータス概要",
  "selfHosting.discord.commands.agents": "<code>/agents</code> - ルーム内のすべてのエージェントを一覧表示",
  "selfHosting.discord.commands.context": "<code>/context</code> - 最近の共有コンテキスト",
  "selfHosting.discord.commands.search": "<code>/search</code> - エージェントメモリを検索",
  "selfHosting.discord.commands.recall": "<code>/recall</code> - 特定のエージェントのメッセージを呼び出す",
  "selfHosting.discord.commands.inject": "<code>/inject</code> - エージェントにコンテキストをプッシュ",
  "selfHosting.discord.commands.inbox": "<code>/inbox</code> - 保留中のインジェクションを確認",
  "selfHosting.discord.commands.knowledge": "<code>/knowledge</code> - ナレッジベースを閲覧",
  "selfHosting.discord.commands.learn": "<code>/learn</code> - 新しいナレッジを保存",
  "selfHosting.discord.commands.msg": "<code>/msg</code> - ルームにメッセージを送信",
  "selfHosting.discord.commands.destination": "<code>/destination</code> - チーム目的地を表示または設定",
  "selfHosting.discord.commands.course": "<code>/course</code> - 目的地への進捗を確認",
  "selfHosting.discord.commands.network": "<code>/network</code> - グローバルインサイトネットワークをクエリ",
  "selfHosting.vscode.heading": "5. VS Code 拡張機能（オプション）",
  "selfHosting.vscode.description": "VS Code 拡張機能は、エージェントツリーサイドバー、アクティビティフィード、コンテキストインジェクション、ナレッジレンズを表示します。ビルド手順については <code>vscode-extension/</code> を参照してください。",
  "selfHosting.updateMcpUrl.heading": "MCP URL の更新",
  "selfHosting.updateMcpUrl.description": "独自の Worker をデプロイした後、エージェント設定の MCP URL を更新して、ホストされたバージョンではなく Worker を指すようにします。<code>mcp.eywa-ai.dev</code> を Worker の URL に置き換えます：",
  "pi.title": "Pi ディスプレイ",
  "pi.lead": "物理的な Eywa ディスプレイのための Raspberry Pi スクリプトです。2 つのハードウェアオプションが異なる役割を果たします：e-ink ディスプレイはアンビエントステータスボードと AR トラッキングアンカーとして機能し、TFT タッチディスプレイはエージェントとの直接対話を提供します。Pi がない場合、ブラウザを持つ任意のデバイスがフォールバックとして機能します。",
  "pi.hardware.heading": "ハードウェア",
  "pi.hardware.table.display": "ディスプレイ",
  "pi.hardware.table.resolution": "解像度",
  "pi.hardware.table.type": "タイプ",
  "pi.hardware.table.script": "スクリプト",
  "pi.hardware.table.waveshare.name": "Waveshare 5.65\" 7 色 ACeP",
  "pi.hardware.table.waveshare.type": "E-Ink（パッシブ）",
  "pi.hardware.table.tft.name": "3.5\" ILI9341 TFT",
  "pi.hardware.table.tft.type": "LCD（タッチ）",
  "pi.displayStrategy.heading": "ディスプレイ戦略",
  "pi.displayStrategy.eink.heading": "E-ink（マット表面） - AR アンカー + アンビエントステータス",
  "pi.displayStrategy.eink.matteTracking": "マット e-ink は反射がゼロで、Spectacles 画像トラッキングに信頼性があります",
  "pi.displayStrategy.eink.fixedMarker": "ディスプレイの右側の固定トラッキングマーカーが AR UI を物理ディスプレイに固定します",
  "pi.displayStrategy.eink.noTouch": "タッチ入力なし。Spectacles はハンドトラッキングとピンチジェスチャーで対話を提供します",
  "pi.displayStrategy.eink.refresh": "デフォルトで 5 分ごとに更新します（<code>--interval</code> で設定可能）、エージェントステータス、ルーム情報、トラッキングマーカー付き",
  "pi.displayStrategy.eink.lowPower": "低消費電力。バッテリーパックで数時間動作します。",
  "pi.displayStrategy.tft.heading": "TFT タッチ（光沢 LCD） - インタラクティブコントロールサーフェス",
  "pi.displayStrategy.tft.noTracking": "トラッキングマーカーなし。光沢画面は画像トラッキングを妨げる反射を引き起こします",
  "pi.displayStrategy.tft.directTouch": "直接タッチ対話：エージェントをタップ、インジェクションを送信、メモリを閲覧",
  "pi.displayStrategy.tft.refreshRate": "応答性の高い UI のための高いリフレッシュレート（30fps）",
  "pi.displayStrategy.tft.useCase": "Spectacles なしでエージェントと対話したい場合に使用",
  "pi.wiring.heading": "配線",
  "pi.wiring.eink.heading": "E-Ink（Waveshare HAT）",
  "pi.wiring.eink.description": "HAT を Pi GPIO ヘッダーに差し込むだけです。追加の配線は不要です。スタンドアロンモジュール（HAT なし）の場合は、以下のインタラクティブダイアグラムを使用して、接続するピンを確認してください。",
  "pi.wiring.eink.moduleHeading": "Waveshare モジュール配線",
  "pi.wiring.eink.moduleHint": "デバイスタイプを選択して、GPIO 接続を確認します。任意のピンにホバーして、ワイヤをトレースします。",
  "pi.wiring.tft.heading": "TFT（ILI9341 3.5\" + XPT2046 タッチ）",
  "pi.wiring.tft.description": "ILI9341 ディスプレイと XPT2046 タッチコントローラーは SPI バスを共有します。LCD とタッチレイヤーを独立して切り替えて、どのピンが共有されているかを確認します。",
  "pi.einkSetup.heading": "E-Ink セットアップ（Waveshare 5.65\" ACeP）",
  "pi.einkSetup.step1.heading": "1. Pi で SPI を有効化",
  "pi.einkSetup.step2.heading": "2. Waveshare ライブラリをインストール",
  "pi.einkSetup.step3.heading": "3. Python 依存関係をインストール",
  "pi.einkSetup.step4.heading": "4. 環境を設定",
  "pi.einkSetup.step5.heading": "5. 実行",
  "pi.einkSetup.step6.heading": "6. 起動時の自動起動（systemd）",
  "pi.tftSetup.heading": "TFT タッチセットアップ（ILI9341 3.5\"）",
  "pi.tftSetup.step1.heading": "1. SPI を有効化 + fbcp をインストール",
  "pi.tftSetup.step2.heading": "2. タッチインターフェースを実行",
  "pi.fallback.heading": "ミニディスプレイフォールバック（電話/タブレット/Web）",
  "pi.fallback.intro": "Raspberry Pi がない場合は、ブラウザを持つ任意のデバイスをディスプレイとして使用できます。Web ダッシュボードには、ディスプレイ最適化ビューが含まれています。",
  "pi.fallback.eink.heading": "MiniEywaEink（アンビエントモード）",
  "pi.fallback.eink.description": "<code>/r/&#123;room-slug&#125;</code> に移動し、e-ink ビューを選択します。ルーム名、エージェントアバターとステータス、アクティビティフィード、ルーム QR コードを含む静的レイアウトをレンダリングします。机に置かれた電話、壁に取り付けられた古いタブレット、または Chromium をキオスクモードで実行している Raspberry Pi に便利です。",
  "pi.fallback.spectacles.heading": "SpectaclesView（AR ストリーミング）",
  "pi.fallback.spectacles.description": "<code>/r/&#123;room-slug&#125;/spectacles</code> に移動し、「Broadcast」をクリックします。これにより、タイルテクスチャがレンダリングされ、Supabase Realtime 経由で接続された Spectacles にストリーミングされます。",
  "pi.testScripts.heading": "テストスクリプト",
  "pi.testScripts.intro": "完全な Eywa アプリを使用する前に、配線後に実行してハードウェアを確認します。",
  "pi.testScripts.table.script": "スクリプト",
  "pi.testScripts.table.whatItTests": "テスト内容",
  "pi.testScripts.table.displayNeeded": "ディスプレイが必要？",
  "pi.testScripts.table.tft.tests": "TFT カラーバー、テキストレンダリング、タッチ入力",
  "pi.testScripts.table.tft.display": "TFT（またはラップトップ用に <code>--window</code>）",
  "pi.testScripts.table.eink.tests": "E-ink 7 色スウォッチ、シェイプ、ピクセルグリッド",
  "pi.testScripts.table.eink.display": "E-ink（または PNG 用に <code>--preview</code>、ディスプレイをワイプするために <code>--clear</code>）",
  "pi.testScripts.table.touch.tests": "生タッチイベント、座標範囲、デバイス検出",
  "pi.testScripts.table.touch.display": "なし（カーネル入力を読み取る）"
}
