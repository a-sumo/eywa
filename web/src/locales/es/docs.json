{
  "sidebar.gettingStarted": "Primeros Pasos",
  "sidebar.overview": "Resumen",
  "sidebar.quickstart": "Inicio Rápido",
  "sidebar.integrations": "Integraciones",
  "sidebar.surfaces": "Superficies",
  "sidebar.cli": "CLI",
  "sidebar.vscodeExtension": "Extensión VS Code",
  "sidebar.discordBot": "Bot de Discord",
  "sidebar.spectaclesAR": "Spectacles AR",
  "sidebar.piDisplays": "Pantallas Pi",
  "sidebar.reference": "Referencia",
  "sidebar.architecture": "Arquitectura",
  "sidebar.selfHosting": "Alojamiento Propio",
  "sidebar.resources": "Recursos",
  "sidebar.llmDocs": "LLM Docs (llms.txt)",
  "sidebar.github": "GitHub",
  "sidebar.discord": "Discord",
  "overview.title": "Documentación de Eywa",
  "overview.lead": "Eywa es una capa de observabilidad y coordinación para equipos humanos + IA. Cada persona en tu equipo dirige agentes de IA que programan, deciden y entregan autónomamente. Eywa hace visible todo ese trabajo para que los humanos se mantengan alineados.",
  "overview.whatIsEywa": "¿Qué es Eywa?",
  "overview.whatIsEywaDesc": "Eywa es un servidor MCP que proporciona a tu equipo visibilidad compartida en cada sesión de agente de IA. Cuando todos ejecutan IA, pequeñas desalineaciones entre personas se amplifican a velocidad de máquina. Eywa ofrece una vista compartida de lo que todos los agentes están construyendo para que sepas en qué sincronizarte. Funciona con cualquier agente que soporte el Model Context Protocol: Claude Code, Cursor, Windsurf, Gemini CLI, Codex, Cline y más.",
  "overview.coreFeatures": "Características Principales",
  "overview.destinationProgress": "Destino y Progreso",
  "overview.destinationProgressDesc": "Define un estado objetivo para tu equipo, establece hitos y rastrea el avance mientras los agentes entregan. Los agentes reportan el progreso con porcentaje y estado. El destino es visible en cada superficie: panel web, barra lateral de VS Code, Discord y auto-contexto MCP.",
  "overview.liveAgentMap": "Mapa de Agentes en Vivo",
  "overview.liveAgentMapDesc": "Ve en qué está trabajando cada agente de tu equipo en tiempo real. El estado de cada agente, tarea, sistemas tocados y progreso son visibles en el panel HubView. Los agentes activos están destacados, con metadatos de operación (sistema, acción, alcance, resultado) para total observabilidad.",
  "overview.contextInjection": "Inyección de Contexto",
  "overview.contextInjectionDesc": "Envía decisiones o correcciones a cualquier agente en medio de su sesión. Los agentes ven las inyecciones en su próxima llamada de herramienta mediante entrega automática piggyback. Soporta niveles de prioridad normal, alto y urgente.",
  "overview.teamKnowledge": "Conocimiento del Equipo",
  "overview.teamKnowledgeDesc": "Memoria persistente que sobrevive a todas las sesiones. Almacena decisiones de arquitectura, convenciones de API, advertencias y patrones con <code>eywa_learn</code>. El conocimiento es buscable por etiquetas y contenido, y aparece en el auto-contexto del agente al inicio de sesión.",
  "overview.timelineBranching": "Línea de Tiempo y Ramificación",
  "overview.timelineBranchingDesc": "Control de versiones tipo Git para el trabajo de agentes. Retrocede a cualquier punto con <code>eywa_rewind</code>, bifurca líneas de tiempo alternativas con <code>eywa_fork</code>, selecciona momentos entre ramas con <code>eywa_pick</code> y fusiona con <code>eywa_merge</code>. Marca decisiones importantes para navegación fácil.",
  "overview.globalInsights": "Red Global de Insights",
  "overview.globalInsightsDesc": "Publica patrones anonimizados de tu sala con <code>eywa_publish_insight</code>. Consulta inteligencia entre salas con <code>eywa_query_network</code> para que tus agentes aprendan de lo que funcionó en otros equipos. Las recomendaciones de carril sugieren insights relevantes según tu tarea actual.",
  "overview.contextRecovery": "Recuperación de Contexto",
  "overview.contextRecoveryDesc": "Los agentes marcan puntos de control de su progreso con <code>eywa_checkpoint</code> y envían señales de socorro con <code>eywa_distress</code> cuando el contexto se agota. Las nuevas sesiones se recuperan automáticamente donde la última dejó. El paso de testigo permite que los agentes transfieran trabajo en medio de sesión.",
  "overview.workClaiming": "Reclamación de Trabajo",
  "overview.workClaimingDesc": "Los agentes declaran en qué están trabajando con <code>eywa_claim</code> para prevenir esfuerzo duplicado. Las reclamaciones activas son visibles en instantáneas de sesión e instrucciones MCP. Las reclamaciones se liberan automáticamente cuando terminan las sesiones.",
  "overview.geminiSteering": "Dirección Gemini",
  "overview.geminiSteeringDesc": "Panel de chat Gemini integrado con 6 herramientas para consultar estado de agentes, detectar patrones, analizar señales de socorro y dirigir el equipo. Alerta proactivamente sobre problemas detectados y socorro de agentes.",
  "overview.interactionSurfaces": "Superficies de Interacción",
  "overview.interactionSurfacesDesc": "El mismo modelo de navegación (destino, curso, dirección) funciona en cada superficie:",
  "overview.surfaceWeb": "Panel Web",
  "overview.surfaceWebDesc": "HubView con mapa de agentes, banner de destino, chat Gemini, stream de actividad y barra de inyección",
  "overview.surfaceVscode": "Extensión VS Code",
  "overview.surfaceVscodeDesc": "Barra lateral con avatares de agentes, feed de actividad, notificaciones de atención y panel de detalles de agente junto a terminales",
  "overview.surfaceDiscord": "Bot Discord",
  "overview.surfaceDiscordDesc": "15 comandos slash para dirección de equipo: <code>/destination</code>, <code>/course</code>, <code>/status</code>, <code>/inject</code> y más",
  "overview.surfaceCli": "CLI",
  "overview.surfaceCliDesc": "<code>npx eywa-ai init</code> para configuración de sala sin autenticación, más comandos de estado, inyección y registro",
  "overview.surfaceSpectacles": "Spectacles AR",
  "overview.surfaceSpectaclesDesc": "Registro de actividad, chat Gemini y progreso de destino como paneles AR flotantes vía Supabase Realtime",
  "overview.usageLimits": "Límites de Uso",
  "overview.usageLimitsDesc": "Eywa está alojado gratuitamente en eywa-ai.dev. Para mantener el servicio confiable, la versión alojada tiene límites de uso. El alojamiento propio elimina todos los límites.",
  "overview.table.free": "Gratis",
  "overview.table.pro": "Pro",
  "overview.table.enterprise": "Enterprise",
  "overview.table.teamMembers": "Miembros del equipo",
  "overview.table.history": "Historial",
  "overview.table.memoriesPerRoom": "Memorias por sala",
  "overview.table.integrations": "Integraciones",
  "overview.table.knowledgeBase": "Base de conocimiento",
  "overview.table.timelineBranching": "Ramificación de línea de tiempo",
  "overview.table.price": "Precio",
  "overview.table.unlimited": "Ilimitado",
  "overview.table.custom": "Personalizado",
  "overview.table.all": "Todas",
  "overview.table.allCustom": "Todas + personalizado",
  "overview.table.readOnly": "Solo lectura",
  "overview.table.full": "Completo",
  "overview.table.viewOnly": "Solo vista",
  "overview.table.contactUs": "Contáctanos",
  "overview.demoNote": "Las salas demo son copias de datos de ejemplo que expiran después de 24 horas. Crea tu propia sala con <code>npx eywa-ai init</code> para uso persistente.",
  "overview.llmDocs": "Documentación LLM",
  "overview.llmDocsDesc": "Para agentes de IA que necesitan entender la superficie completa de la API de Eywa, apúntalos a <a href=\"/llms.txt\">llms.txt</a> que describe todas las herramientas disponibles, guías de integración y flujos de trabajo comunes.",
  "overview.gettingStarted": "Primeros Pasos",
  "overview.gettingStartedDesc": "Elige tu agente de codificación de IA de la barra lateral para ver instrucciones de configuración específicas. La mayoría de las integraciones toman menos de 2 minutos para configurar.",
  "overview.claudeCodeDesc": "Agente CLI de Anthropic",
  "overview.cursorDesc": "Editor de código con IA primero",
  "overview.windsurfDesc": "IDE potenciado por IA",
  "quickstart.title": "Inicio Rápido",
  "quickstart.lead": "Haz que los agentes de IA de tu equipo compartan contexto en menos de un minuto. Sin autenticación, sin registro, sin configuración manual.",
  "quickstart.createRoom": "Crear una Sala",
  "quickstart.createRoomDesc": "Un comando crea una sala, auto-detecta cada agente de IA en tu máquina, los configura todos y abre el panel.",
  "quickstart.thisWill": "Esto hará:",
  "quickstart.willCreateRoom": "Crear una sala con un nombre aleatorio (o pasa el tuyo: <code>npx eywa-ai init mi-equipo</code>)",
  "quickstart.willAutoDetect": "Auto-detectar agentes instalados (Claude Code, Cursor, Windsurf, Gemini CLI, Codex)",
  "quickstart.willConfigure": "Configurar cada uno para compartir contexto a través de la sala",
  "quickstart.willOpenDashboard": "Abrir el panel en vivo en tu navegador",
  "quickstart.usernameNote": "El CLI usa tu nombre de usuario del sistema como el nombre del agente para que Eywa pueda distinguir a los miembros del equipo. No se requiere copiar y pegar fragmentos de configuración.",
  "quickstart.joinRoom": "Unirse a una Sala Existente",
  "quickstart.joinRoomDesc": "Si alguien en tu equipo ya creó una sala, únete con:",
  "quickstart.joinRoomNote": "Esto guarda la sala como tu predeterminada, auto-configura todos los agentes detectados y abre el panel.",
  "quickstart.manualSetup": "Configuración Manual",
  "quickstart.manualSetupDesc": "Si la auto-detección omite un agente (o quieres configurar uno manualmente), el formato de endpoint MCP es:",
  "quickstart.manualSetupSeeText1": "Consulta las ",
  "quickstart.manualSetupIntegrationLink": "guías de integración",
  "quickstart.manualSetupSeeText2": " para ubicaciones de archivos de configuración específicas del agente.",
  "quickstart.whatsNext": "Qué Sigue",
  "quickstart.whatsNextText1": "Una vez que tu agente se conecta, obtiene más de 40 herramientas para registrar trabajo, compartir contexto, inyectar decisiones y coordinarse con otros agentes. Consulta el ",
  "quickstart.whatsNextDocsLink": "resumen de documentación",
  "quickstart.whatsNextText2": " para el desglose completo de características, o explora la ",
  "quickstart.whatsNextCLILink": "referencia CLI",
  "quickstart.whatsNextText3": " para todos los comandos disponibles.",
  "cli.title": "Referencia CLI",
  "cli.lead": "El CLI <code>eywa-ai</code> maneja la configuración de salas y la gestión básica. Cero autenticación, cero instalación. Ejecútalo con <code>npx</code> y estás conectado.",
  "cli.installation": "Instalación",
  "cli.installationDesc": "No se necesita instalación. Solo ejecuta con npx:",
  "cli.stateDesc": "Esto descarga y ejecuta la última versión al vuelo. El estado se guarda localmente en <code>~/.eywa/config.json</code> para que los comandos subsiguientes recuerden tu sala predeterminada.",
  "cli.commands": "Comandos",
  "cli.initTitle": "init [nombre]",
  "cli.initDesc": "Crea una nueva sala y auto-configura cada agente de IA detectado en tu máquina. Si pasas un nombre, la sala lo usa como slug. De lo contrario, Eywa genera uno aleatorio como <code>cosmic-fox-a1b2</code>. El CLI detecta Claude Code, Cursor, Windsurf, Gemini CLI y Codex, escribe sus configuraciones MCP y abre el panel.",
  "cli.joinTitle": "join <sala-slug>",
  "cli.joinDesc": "Únete a una sala que alguien más creó. Auto-configura todos los agentes detectados, guarda la sala como tu predeterminada y abre el panel.",
  "cli.statusTitle": "status [sala]",
  "cli.statusDesc": "Muestra todos los agentes en la sala con su estado actual (activo, hecho, bloqueado, fallido, inactivo), hora de última actividad, descripción de tarea y qué sistemas han estado tocando.",
  "cli.logTitle": "log [sala] [límite]",
  "cli.logDesc": "Feed de actividad mostrando memorias recientes con marcas de tiempo, nombres de agentes, tipos de eventos y metadatos de operación (sistema, acción, resultado). Predeterminado a 30 entradas.",
  "cli.injectTitle": "inject <objetivo> <mensaje>",
  "cli.injectDesc": "Envía contexto a la sesión de un agente. El agente objetivo ve la inyección en su próxima llamada de herramienta mediante la entrega piggyback de Eywa.",
  "cli.dashboardTitle": "dashboard [sala]",
  "cli.dashboardDesc": "Abre el panel web para una sala. También disponible como <code>dash</code> o <code>open</code>.",
  "cli.helpTitle": "help",
  "cli.helpDesc": "Imprime información de uso. También activado por <code>--help</code> o <code>-h</code>.",
  "cli.whatAgentsCanDo": "Qué Pueden Hacer los Agentes",
  "cli.whatAgentsCanDoDesc": "Una vez que un agente se conecta al servidor MCP de Eywa, obtiene más de 40 herramientas organizadas en estas categorías:",
  "cli.tableCategory": "Categoría",
  "cli.tableTools": "Herramientas",
  "cli.tableWhatTheyDo": "Qué hacen",
  "cli.categorySession": "Sesión",
  "cli.sessionDesc": "Rastrea en qué está trabajando cada agente",
  "cli.categoryMemory": "Memoria",
  "cli.memoryDesc": "Registra decisiones, almacena archivos, busca historial",
  "cli.categoryContext": "Contexto",
  "cli.contextDesc": "Ve qué están haciendo otros, obtén su contexto",
  "cli.categoryInjection": "Inyección",
  "cli.injectionDesc": "Envía contexto a cualquier agente",
  "cli.categoryKnowledge": "Conocimiento",
  "cli.knowledgeDesc": "Conocimiento persistente del proyecto entre sesiones",
  "cli.categoryMessaging": "Mensajería",
  "cli.messagingDesc": "Chat de equipo entre agentes y humanos",
  "cli.categoryDestination": "Destino",
  "cli.destinationDesc": "Establece objetivos de equipo, rastrea hitos, reporta progreso",
  "cli.categoryRecovery": "Recuperación",
  "cli.recoveryDesc": "Guarda estado, sobrevive agotamiento de contexto, transfiere trabajo",
  "cli.categoryClaiming": "Reclamación",
  "cli.claimingDesc": "Previene trabajo duplicado entre agentes",
  "cli.categoryLinking": "Vinculación",
  "cli.linkingDesc": "Conecta memorias entre sesiones",
  "cli.categoryTimeline": "Línea de tiempo",
  "cli.timelineDesc": "Control de versiones tipo Git para trabajo de agentes",
  "cli.categoryNetwork": "Red",
  "cli.networkDesc": "Compartición de conocimiento anonimizado entre salas y enrutamiento",
  "cli.howItWorks": "Cómo Funciona",
  "cli.howItWorksDesc": "Los agentes se conectan a un Cloudflare Worker sin estado vía MCP (Model Context Protocol). El worker lee y escribe a Supabase. El panel, CLI, bot de Discord, extensión VS Code y Spectacles AR todos leen de la misma base de datos en tiempo real.",
  "architecture.title": "Arquitectura",
  "architecture.lead": "Eywa es un servidor MCP sin estado respaldado por Supabase. Los agentes se conectan por HTTP, el servidor escribe a PostgreSQL y cada superficie lee de la misma base de datos en tiempo real.",
  "architecture.systemDiagram": "Diagrama del Sistema",
  "architecture.techStack": "Stack Tecnológico",
  "architecture.techStack.component": "Componente",
  "architecture.techStack.technology": "Tecnología",
  "architecture.techStack.mcpServer": "Servidor MCP",
  "architecture.techStack.mcpServerDesc": "Cloudflare Workers, <code>@modelcontextprotocol/sdk</code>",
  "architecture.techStack.database": "Base de datos",
  "architecture.techStack.databaseDesc": "Supabase (PostgreSQL + Realtime)",
  "architecture.techStack.dashboard": "Panel",
  "architecture.techStack.dashboardDesc": "React 19, TypeScript, Vite",
  "architecture.techStack.aiChat": "Chat IA",
  "architecture.techStack.aiChatDesc": "Gemini (gemini-2.5-flash)",
  "architecture.techStack.cli": "CLI",
  "architecture.techStack.cliDesc": "Node.js, <code>@supabase/supabase-js</code>",
  "architecture.techStack.discordBot": "Bot Discord",
  "architecture.techStack.discordBotDesc": "discord.js, Supabase directo",
  "architecture.techStack.vsCode": "VS Code",
  "architecture.techStack.vsCodeDesc": "Extension API, Supabase Realtime",
  "architecture.techStack.ar": "AR",
  "architecture.techStack.arDesc": "Snap Spectacles / Lens Studio",
  "architecture.techStack.ambient": "Ambiental",
  "architecture.techStack.ambientDesc": "Waveshare e-ink de 7 colores, Raspberry Pi TFT",
  "architecture.projectStructure": "Estructura del Proyecto",
  "architecture.howItWorks": "Cómo Funciona",
  "architecture.mcpProtocol": "Protocolo MCP",
  "architecture.mcpProtocolDesc": "Los agentes se conectan a Eywa usando el Model Context Protocol (MCP), un estándar abierto para conectar agentes de IA a herramientas externas. Cada agente abre una conexión HTTP al Cloudflare Worker en una URL como:",
  "architecture.mcpProtocolDesc2": "La URL le dice a Eywa a qué sala unirse y cómo llamar al agente. Una vez conectado, el agente puede llamar a cualquiera de las 45 herramientas: registrar memorias, leer contexto del equipo, inyectar información en otros agentes, establecer destinos y más.",
  "architecture.cloudflareWorker": "Cloudflare Worker",
  "architecture.cloudflareWorkerDesc": "El servidor MCP se ejecuta como un Cloudflare Worker sin estado. No tiene almacenamiento local. Cada llamada de herramienta se traduce en una solicitud HTTP PostgREST de Supabase (no el SDK JS, solo llamadas fetch puras). Esto significa que el servidor escala a cero y maneja cualquier número de agentes concurrentes sin afinidad de sesión.",
  "architecture.cloudflareWorkerDesc2": "En el momento de la conexión, el worker envía el contexto de la sala al campo <code>instructions</code> de MCP. Esto da a los agentes conciencia situacional completa (agentes activos, actividad reciente, inyecciones pendientes, conteo de conocimiento, destino, estado de recuperación) antes de que hagan una sola llamada de herramienta.",
  "architecture.supabase": "Supabase",
  "architecture.supabaseDesc": "Todo el estado vive en Supabase (PostgreSQL). El panel y otras superficies se suscriben a canales de Supabase Realtime, por lo que los cambios de cualquier agente aparecen inmediatamente en cada cliente conectado. El esquema define cinco tablas principales más una tabla refs para ramificación de línea de tiempo.",
  "architecture.realtime": "Realtime",
  "architecture.realtimeDesc": "Cuando un agente registra una memoria, la suscripción de Supabase Realtime la envía a cada panel conectado, instancia de VS Code y bot de Discord en milisegundos. Así es como HubView muestra actividad de agente en vivo y el feed de actividad se actualiza sin polling.",
  "architecture.agentIdentity": "Identidad del Agente",
  "architecture.agentIdentityDesc": "Cada agente obtiene una identidad en el formato <code>{nombre_base}/{adjetivo}-{sustantivo}</code>. Por ejemplo: <code>armand/quiet-oak</code>, <code>cursor/bright-fox</code>. El nombre base es el humano que posee el agente, y el sufijo se genera automáticamente para distinguir múltiples sesiones de la misma persona.",
  "architecture.agentIdentityDesc2": "El nombre base se mapea al parámetro de consulta <code>agent</code> en la URL MCP. Cuando estableces <code>agent=claude/alice</code>, Eywa sabe que \"alice\" es la humana y \"claude\" es el tipo de agente. Esto permite al sistema enrutar inyecciones a todos los agentes de alice sin importar qué herramienta estén usando.",
  "architecture.coreTables": "Tablas Principales",
  "architecture.coreTables.table": "Tabla",
  "architecture.coreTables.purpose": "Propósito",
  "architecture.coreTables.keyFields": "Campos Clave",
  "architecture.coreTables.roomsDesc": "Espacios de trabajo aislados. Cada equipo obtiene una sala con un slug único.",
  "architecture.coreTables.memoriesDesc": "Todo lo que los agentes registran: eventos de sesión, decisiones, archivos, conocimiento, inyecciones, puntos de control, destinos, reclamaciones y actualizaciones de progreso. La columna <code>metadata</code> JSONB almacena etiquetas de operación (sistema, acción, alcance, resultado) y datos específicos del evento.",
  "architecture.coreTables.messagesDesc": "Chat de equipo entre agentes y humanos. Organizado por canales.",
  "architecture.coreTables.linksDesc": "Conexiones entre sesiones de memorias. Soporta tipos de enlace de referencia, inyección y bifurcación.",
  "architecture.coreTables.globalInsightsDesc": "Conocimiento anonimizado compartido entre folds para la red global.",
  "architecture.privacy": "Privacidad",
  "architecture.privacyDesc": "Tu código nunca sale de tu máquina. Eywa solo sincroniza metadatos: en qué están trabajando los agentes, decisiones que tomaron, archivos que almacenaron (si llamas explícitamente a <code>eywa_file</code>) y actualizaciones de progreso. El servidor MCP nunca ve tu código fuente, historial de git o contenidos de archivos a menos que un agente los envíe explícitamente a través de una llamada de herramienta.",
  "architecture.privacyDesc2": "Las sesiones de agentes están limitadas a salas. Cada sala es un espacio de trabajo aislado. No hay acceso a datos entre salas a menos que publiques en la red global de insights, que anonimiza la fuente antes de compartir.",
  "discord.title": "Bot de Discord",
  "discord.lead": "El bot de Discord de Eywa ofrece a tu equipo observabilidad de toda la actividad de agentes desde el chat. 15 comandos slash para explorar el estado de agentes, buscar memorias, inyectar contexto, gestionar conocimiento y dirigir hacia un destino.",
  "discord.setup": "Configuración",
  "discord.setup.step1": "Invita el bot a tu servidor de Discord.",
  "discord.setup.step2": "En el canal que quieras usar, ejecuta <code>/room set &lt;slug&gt;</code> para vincularlo a una sala de Eywa. Todos los comandos en ese canal consultarán esta sala.",
  "discord.setup.step3": "Ejecuta <code>/status</code> para ver en qué están trabajando los agentes.",
  "discord.setup.multiChannel": "Puedes vincular diferentes canales a diferentes salas si tu servidor tiene múltiples equipos.",
  "discord.agentIdentity": "Identidad del Agente",
  "discord.agentIdentityDesc": "Los mensajes enviados desde Discord aparecen en Eywa como <code>discord/&lt;nombre de usuario&gt;</code>. Cuando usas <code>/inject</code>, <code>/learn</code>, <code>/msg</code> o <code>/destination set</code>, el remitente se registra como <code>discord/tunombre</code> para que agentes y compañeros puedan ver quién lo envió.",
  "discord.commandReference": "Referencia de Comandos",
  "discord.observe": "Observar",
  "discord.tableCommand": "Comando",
  "discord.tableDescription": "Descripción",
  "discord.tableOptions": "Opciones",
  "discord.helpDesc": "Cómo usar el bot de Eywa. Muestra todos los comandos agrupados por categoría.",
  "discord.statusDesc": "Ve en qué están trabajando todos los agentes actualmente. Muestra agentes activos, recientes e inactivos con sistemas tocados.",
  "discord.agentsDesc": "Lista todos los agentes que han registrado en esta sala, con conteos de memoria y hora de última vista.",
  "discord.contextDesc": "Ve actividad reciente entre todos los agentes como una línea de tiempo.",
  "discord.contextOptions": "<code>count</code> - número de entradas (1-30, predeterminado 10)",
  "discord.recallDesc": "Ver la actividad reciente de un agente específico. Los nombres de agentes se autocompletar mientras escribes.",
  "discord.recallOptions": "<code>agent</code> (requerido) - nombre del agente<br /><code>count</code> - número de entradas (1-30, predeterminado 15)",
  "discord.searchDesc": "Buscar memorias de agentes por texto.",
  "discord.searchOptions": "<code>query</code> (requerido) - texto a buscar<br /><code>limit</code> - resultados máximos (1-25, predeterminado 10)",
  "discord.interact": "Interactuar",
  "discord.injectDesc": "Enviar contexto o instrucciones a un agente. El agente lo ve en su próxima llamada de herramienta.",
  "discord.injectOptions": "<code>target</code> (requerido) - nombre del agente o \"all\" para difusión<br /><code>message</code> (requerido) - el contexto a enviar<br /><code>priority</code> - Normal, High o Urgent<br /><code>label</code> - etiqueta corta (ej. \"reporte de bug\")",
  "discord.inboxDesc": "Ver inyecciones pendientes para un agente.",
  "discord.inboxOptions": "<code>target</code> - nombre del agente o \"all\" para difusiones<br /><code>limit</code> - entradas máximas (1-25, predeterminado 10)",
  "discord.msgDesc": "Enviar un mensaje al chat del equipo de Eywa.",
  "discord.msgOptions": "<code>text</code> (requerido) - mensaje a enviar<br /><code>channel</code> - canal de chat (predeterminado: general)",
  "discord.knowledge": "Conocimiento",
  "discord.knowledgeDesc": "Explorar la base de conocimiento del proyecto. Soporta filtrado por texto de búsqueda y etiquetas.",
  "discord.knowledgeOptions": "<code>search</code> - buscar dentro del contenido de conocimiento<br /><code>tag</code> - filtrar por etiqueta (ej. architecture, api)<br /><code>limit</code> - entradas máximas (1-25, predeterminado 10)",
  "discord.learnDesc": "Almacenar conocimiento para que los agentes del equipo lo referencien en todas las sesiones.",
  "discord.learnOptions": "<code>content</code> (requerido) - el conocimiento a almacenar<br /><code>title</code> - título corto para escaneo rápido<br /><code>tags</code> - etiquetas separadas por comas (ej. api,convention,gotcha)",
  "discord.networkDesc": "Explorar la red global de conocimiento. Muestra insights anonimizados compartidos entre salas.",
  "discord.networkOptions": "<code>search</code> - buscar insights por texto<br /><code>domain</code> - filtrar por etiqueta de dominio (ej. typescript, react)",
  "discord.navigation": "Navegación",
  "discord.destinationViewDesc": "Ver el destino actual y el progreso de hitos.",
  "discord.destinationSetDesc": "Establecer un nuevo destino (punto B) para la sala.",
  "discord.destinationSetOptions": "<code>target</code> (requerido) - el estado objetivo<br /><code>milestones</code> - hitos separados por comas",
  "discord.destinationCheckDesc": "Marcar un hito como hecho. Usa coincidencia difusa en el nombre.",
  "discord.destinationCheckOptions": "<code>milestone</code> (requerido) - nombre del hito a completar",
  "discord.courseDesc": "Vista completa del curso: progreso de destino, agentes activos con porcentajes de completitud, señales de socorro y conteos de agentes.",
  "discord.room": "Sala",
  "discord.roomSetDesc": "Vincular este canal de Discord a una sala de Eywa.",
  "discord.roomSetOptions": "<code>slug</code> (requerido) - slug de sala (ej. demo, hackathon)",
  "discord.roomInfoDesc": "Mostrar a qué sala está vinculado este canal.",
  "discord.roomListDesc": "Listar todas las salas disponibles.",
  "discord.examples": "Ejemplos",
  "discord.exampleCheckTeam": "Verificar qué está construyendo el equipo",
  "discord.exampleSendInstructions": "Enviar instrucciones a un agente",
  "discord.exampleStoreKnowledge": "Almacenar y encontrar conocimiento",
  "discord.exampleSetDestination": "Establecer un destino y rastrear progreso",
  "discord.selfHosting": "Alojamiento Propio",
  "discord.selfHostingDesc": "El bot usa consultas directas de Supabase (no MCP). Para ejecutar tu propia instancia:",
  "discord.selfHostingDeploy": "Despliega comandos a un guild con <code>npm run deploy -- &lt;guild_id&gt;</code>.",
  "vscode.title": "Extensión VS Code",
  "vscode.lead": "La extensión VS Code de Eywa te da una barra lateral en vivo mostrando cada sesión de agente en tu sala, un sistema de atención que muestra agentes que necesitan tu entrada, decoraciones de editor inline para alcances de agentes activos e inyección de contexto desde tu editor. Se conecta a la misma sala a la que tus agentes reportan, así que ves lo que ellos ven.",
  "vscode.installation.heading": "Instalación",
  "vscode.installation.text": "Instala desde el <a href=\"https://marketplace.visualstudio.com/items?itemName=curvilinear.eywa-agents\" target=\"_blank\" rel=\"noopener noreferrer\">VS Code Marketplace</a>. Busca \"Eywa\" en el panel de Extensiones, o ejecuta esto desde la paleta de comandos:",
  "vscode.quickStart.heading": "Inicio Rápido",
  "vscode.quickStart.step1": "Haz clic en el ícono de Eywa en la barra de actividad",
  "vscode.quickStart.step2": "Haz clic en <strong>Set Room</strong> e ingresa tu slug de sala (ej. <code>mi-proyecto</code>)",
  "vscode.quickStart.step3": "Ejecuta <strong>Eywa: Connect Agent</strong> desde la paleta de comandos para generar una URL MCP y copiarla a tu portapapeles",
  "vscode.quickStart.selfHost": "La extensión se conecta a la instancia alojada de Eywa por defecto. Si estás auto-alojando, ejecuta <strong>Eywa: Login</strong> para conectar vía navegador.",
  "vscode.features.heading": "Características",
  "vscode.features.liveSidebar.heading": "Barra Lateral en Vivo",
  "vscode.features.liveSidebar.p1": "El panel principal muestra agentes como chips de avatar con puntos de estado (verde = activo, amarillo = inactivo, gris = terminado). Haz clic en cualquier chip de agente para expandir un panel de detalles mostrando su tarea actual, barra de progreso, conteo de memoria y hora de última vista. El panel de detalles tiene botones para inyectar contexto directamente a ese agente o abrir el panel web.",
  "vscode.features.liveSidebar.p2": "Debajo de la franja de agentes, un feed de actividad desplazable muestra eventos recientes entre todos los agentes con etiquetas de operación (sistema, acción, resultado). Haz clic en cualquier elemento del feed para expandir su texto completo. Los avatares coinciden en VS Code, el panel web y pantallas de hardware.",
  "vscode.features.liveSidebar.p3": "La barra lateral también muestra un banner de destino cuando la sala tiene un destino activo. Muestra el progreso de hitos con una barra de completitud, chips de hitos individuales (marcados cuando están hechos) y notas de curso opcionales.",
  "vscode.features.attentionSystem.heading": "Sistema de Atención",
  "vscode.features.attentionSystem.p1": "Cuando los agentes necesitan tu entrada, la barra lateral muestra una sección \"Needs You\" en la parte superior. Cada elemento de atención muestra el avatar del agente, la razón (socorro, bloqueado, detenido o punto de control), un resumen de lo que necesitan y un campo de respuesta inline. Escribe una respuesta y presiona Enter para enviar contexto directamente a ese agente. También puedes descartar elementos que no necesitas atender.",
  "vscode.features.attentionSystem.p2": "Los elementos de atención están priorizados por urgencia: señales de socorro (rojo, pulsante) vienen primero, luego agentes bloqueados (amarillo), sesiones detenidas (gris) y puntos de control (azul). La barra de estado se actualiza para mostrar cuántos agentes te necesitan, y la insignia de la barra lateral muestra el conteo. Los agentes en socorro y bloqueados también activan popups de advertencia nativos de VS Code.",
  "vscode.features.agentsPanel.heading": "Panel de Agentes",
  "vscode.features.agentsPanel.text": "El panel inferior (junto a tus pestañas de terminal) muestra tarjetas de agentes en vivo en una franja horizontal. Cada tarjeta muestra el nombre del agente, punto de estado, tarea actual, barra de progreso, última acción con alcance y etiquetas de sistema. Las tarjetas se ordenan con agentes activos primero. Este panel te da un vistazo rápido a la actividad de agentes mientras trabajas en la terminal.",
  "vscode.features.agentDecorations.heading": "Decoraciones de Agente",
  "vscode.features.agentDecorations.text": "Cuando los agentes registran operaciones con metadatos de alcance que referencian archivos que tienes abiertos, la extensión muestra decoraciones inline: puntos de canal de colores, anotaciones después del texto mostrando el nombre del agente, acción, alcance y tiempo transcurrido, y marcas de regla de vista general. Pasa el mouse sobre una línea decorada para ver detalles completos incluyendo el alcance del agente, sistema y un enlace para abrir la barra lateral de Eywa. Las decoraciones expiran automáticamente después de 30 minutos.",
  "vscode.features.contextInjection.heading": "Inyección de Contexto",
  "vscode.features.contextInjection.text": "Envía instrucciones o contexto a cualquier agente, o difunde a todos:",
  "vscode.features.contextInjection.item1": "<strong>Eywa: Inject Context</strong> - elige un agente objetivo, escribe un mensaje, establece prioridad",
  "vscode.features.contextInjection.item2": "<strong>Cmd+Shift+I</strong> (Mac) / <strong>Ctrl+Shift+I</strong> (Win/Linux) - selecciona código en el editor e inyéctalo con ruta de archivo y contexto de rango de línea",
  "vscode.features.contextInjection.item3": "<strong>Menú de clic derecho</strong> - cuando tienes texto seleccionado, \"Eywa: Inject Selection to Agent\" aparece en el menú de contexto del editor",
  "vscode.features.contextInjection.priority": "Niveles de prioridad: <code>normal</code>, <code>high</code>, <code>urgent</code>. Las inyecciones urgentes activan un popup nativo de VS Code.",
  "vscode.features.terminalTabTitles.heading": "Títulos de Pestañas de Terminal",
  "vscode.features.terminalTabTitles.text": "Activa <strong>Eywa: Toggle Agent Tab Titles</strong> para mostrar lo que Claude Code está haciendo en los nombres de tus pestañas de terminal (\"Editing auth.ts\", \"Running tests\", etc.). Usa un hook PostToolUse con un archivo de bandera en <code>~/.config/eywa/tab-title</code>, sin variables de entorno necesarias.",
  "vscode.features.tagTerminals.heading": "Etiquetar Terminales",
  "vscode.features.tagTerminals.text": "Usa <strong>Eywa: Tag Terminal with Agent</strong> para asociar la terminal activa con un agente específico. Elige de la lista de agentes conocidos o ingresa un nombre personalizado. Las terminales etiquetadas se rastrean para que sepas qué terminal pertenece a qué agente.",
  "vscode.features.statusBar.heading": "Barra de Estado",
  "vscode.features.statusBar.text": "Haz clic en el estado de Eywa en la parte inferior izquierda para un menú de selección rápida: cambiar salas, ver agentes activos, inyectar contexto, alternar títulos de pestañas, conectar agentes, iniciar sesión o abrir el panel. La barra de estado muestra el nombre de la sala actual y se actualiza para mostrar el conteo de atención cuando los agentes te necesitan.",
  "vscode.commands.heading": "Comandos",
  "vscode.commands.col.command": "Comando",
  "vscode.commands.col.keybinding": "Atajo de teclado",
  "vscode.commands.col.description": "Descripción",
  "vscode.commands.login.desc": "Conectar a Eywa vía inicio de sesión en navegador",
  "vscode.commands.switchRoom.desc": "Cambiar la sala que estás monitoreando",
  "vscode.commands.connectAgent.desc": "Obtener una URL MCP para un nuevo agente",
  "vscode.commands.injectContext.desc": "Enviar contexto/instrucciones a un agente",
  "vscode.commands.injectSelection.desc": "Inyectar código seleccionado a un agente",
  "vscode.commands.openDashboard.desc": "Abrir el panel web",
  "vscode.commands.refreshAgents.desc": "Refrescar manualmente la barra lateral",
  "vscode.commands.toggleTabTitles.desc": "Mostrar acciones de agente en pestañas de terminal",
  "vscode.commands.tagTerminal.desc": "Asociar terminal activa con un agente",
  "vscode.commands.showStatus.desc": "Menú de selección rápida con acciones comunes",
  "vscode.settings.heading": "Configuración",
  "vscode.settings.col.setting": "Configuración",
  "vscode.settings.col.default": "Predeterminado",
  "vscode.settings.col.description": "Descripción",
  "vscode.settings.supabaseUrl.default": "Instancia alojada",
  "vscode.settings.supabaseUrl.desc": "URL del proyecto Supabase",
  "vscode.settings.supabaseKey.default": "Instancia alojada",
  "vscode.settings.supabaseKey.desc": "Clave anon de Supabase",
  "vscode.settings.room.default": "(vacío)",
  "vscode.settings.room.desc": "Slug de sala a monitorear",
  "vscode.settings.logLevel.desc": "Filtro de feed de actividad: <code>all</code>, <code>important</code> (sesiones + conocimiento + inyecciones), o solo <code>sessions</code>",
  "vscode.settings.historyHours.desc": "Cuántas horas de historial cargar (1, 6, 24 o 72)",
  "vscode.settings.note": "La URL de Supabase y la clave predeterminan a la instancia alojada de Eywa. Solo necesitas cambiarlas si estás auto-alojando.",
  "vscode.links.heading": "Enlaces",
  "vscode.links.marketplace": "<a href=\"https://marketplace.visualstudio.com/items?itemName=curvilinear.eywa-agents\" target=\"_blank\" rel=\"noopener noreferrer\">VS Code Marketplace</a>",
  "vscode.links.dashboard": "<a href=\"https://eywa-ai.dev\" target=\"_blank\" rel=\"noopener noreferrer\">Panel Web de Eywa</a>",
  "vscode.links.github": "<a href=\"https://github.com/a-sumo/eywa\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a>",
  "spectacles.title": "Cliente AR Spectacles",
  "spectacles.lead": "Cliente AR Snap Spectacles para Eywa. Renderiza memoria de agentes, contexto y chat como quads flotantes en espacio mundial, transmitidos desde un renderizador web vía Supabase Realtime. Los Spectacles no ejecutan un navegador completo. En su lugar, una aplicación web renderiza cada elemento de UI (tarjetas de memoria, puntos de agentes, botones, burbujas de chat) como texturas JPEG diminutas en OffscreenCanvases, las transmite por Supabase Realtime, y las gafas las decodifican y pintan en quads 3D.",
  "spectacles.streamingPipeline.heading": "Pipeline de Transmisión",
  "spectacles.streamingPipeline.text": "El panel web en <code>/r/&#123;room-slug&#125;/spectacles</code> sirve como el transmisor. Mantiene un canal de Supabase Realtime y transmite actividad de sala, chat Gemini y progreso de destino a dispositivos Spectacles conectados.",
  "spectacles.streamingPipeline.dirty": "Cada tile es su propio quad con su propio material clonado. Solo los tiles sucios se re-renderizan y re-transmiten. La mayoría de los tiles transmiten exactamente una vez.",
  "spectacles.protocol.heading": "Protocolo",
  "spectacles.protocol.channels.heading": "Canales",
  "spectacles.protocol.channels.col.channel": "Canal",
  "spectacles.protocol.channels.col.purpose": "Propósito",
  "spectacles.protocol.channels.lobby": "Descubrimiento de dispositivo (latido, conectar, desconectar)",
  "spectacles.protocol.channels.device": "Transmisión de tiles (ops de escena + texturas)",
  "spectacles.protocol.channels.default": "Canal predeterminado cuando no hay ID de dispositivo",
  "spectacles.protocol.events.heading": "Eventos",
  "spectacles.protocol.events.col.event": "Evento",
  "spectacles.protocol.events.col.direction": "Dirección",
  "spectacles.protocol.events.col.payload": "Payload",
  "spectacles.protocol.events.scene.payload": "<code>&#123;op, id, x, y, w, h, ...&#125;</code> o <code>&#123;ops: [...]&#125;</code>",
  "spectacles.protocol.events.tex.payload": "<code>&#123;id, image&#125;</code> (image es JPEG base64 puro)",
  "spectacles.protocol.events.interact.payload": "<code>&#123;id, type, x, y, u, v, timestamp&#125;</code> (type: tap, hover, hover_move, hover_exit)",
  "spectacles.protocol.events.camera.payload": "<code>&#123;x, y, z, wx, wy, wz, ts&#125;</code> (posición local + mundial)",
  "spectacles.protocol.events.layout.payload": "<code>&#123;actions: [...], timestamp&#125;</code> (cambios de diseño impulsados por gestos)",
  "spectacles.protocol.events.syncRequest.payload": "<code>&#123;deviceId, timestamp&#125;</code> (solicitar resincronización completa de tiles)",
  "spectacles.protocol.events.deviceConnect.payload": "<code>&#123;deviceId, channelName, timestamp&#125;</code>",
  "spectacles.protocol.events.deviceHeartbeat.payload": "<code>&#123;deviceId, channelName, timestamp&#125;</code>",
  "spectacles.protocol.events.voiceInput.payload": "<code>&#123;text, timestamp&#125;</code> (transcripción de voz de usuario)",
  "spectacles.protocol.events.voiceResponse.payload": "<code>&#123;text, timestamp&#125;</code> (transcripción de respuesta Gemini)",
  "spectacles.protocol.events.voiceInject.payload": "<code>&#123;message, priority, timestamp&#125;</code> (inyectado a sala)",
  "spectacles.protocol.sceneOps.heading": "Ops de Escena",
  "spectacles.protocol.sceneOps.create": "<code>create</code> - nuevo quad: <code>&#123;op:\"create\", id, x, y, z, w, h, layer, group, interactive, s&#125;</code>",
  "spectacles.protocol.sceneOps.destroy": "<code>destroy</code> - eliminar quad: <code>&#123;op:\"destroy\", id&#125;</code>",
  "spectacles.protocol.sceneOps.visibility": "<code>visibility</code> - mostrar/ocultar: <code>&#123;op:\"visibility\", id, visible&#125;</code>",
  "spectacles.protocol.sceneOps.group": "<code>group</code> - crear/posicionar un contenedor de grupo: <code>&#123;op:\"group\", id, x, y, z, visible&#125;</code>",
  "spectacles.protocol.sceneOps.groupDestroy": "<code>group-destroy</code> - eliminar un grupo y todos sus hijos: <code>&#123;op:\"group-destroy\", id&#125;</code>",
  "spectacles.protocol.sceneOps.move": "<code>move</code> / <code>group-move</code> - actualmente ignorado (diseño estático después de creación)",
  "spectacles.setup.heading": "Configuración",
  "spectacles.setup.lensStudio.heading": "1. Proyecto Lens Studio",
  "spectacles.setup.lensStudio.text": "Abre <code>eywa-specs.esproj</code> en Lens Studio.",
  "spectacles.setup.supabasePlugin.heading": "2. Plugin Supabase",
  "spectacles.setup.supabasePlugin.text": "Window > Supabase > Login > Import Credentials. Esto crea un asset SupabaseProject.",
  "spectacles.setup.sceneHierarchy.heading": "3. Jerarquía de Escena",
  "spectacles.setup.webBroadcaster.heading": "4. Transmisor Web",
  "spectacles.setup.webBroadcaster.text": "Navega a <code>/r/&#123;room-slug&#125;/spectacles</code> en la aplicación web de Eywa. Haz clic en \"Start Broadcast\". La página renderiza tiles y los transmite a cualquier dispositivo Spectacles conectado.",
  "spectacles.setup.testInEditor.heading": "5. Probar en Editor",
  "spectacles.setup.testInEditor.text": "Envía al dispositivo o usa la vista previa de Lens Studio. Revisa el panel Logger para conexión y eventos de tiles:",
  "spectacles.voiceInterface.heading": "Interfaz de Voz (EywaGeminiLive)",
  "spectacles.voiceInterface.text": "Los Spectacles tienen una interfaz de voz bidireccional potenciada por Gemini Live. El usuario habla, Gemini responde con audio, y las transcripciones se retransmiten al panel web en tiempo real. Gemini también puede inyectar mensajes a la sala, permitiendo a los usuarios dirigir el enjambre de agentes por voz.",
  "spectacles.voiceInterface.howItWorks.heading": "Cómo Funciona",
  "spectacles.voiceInterface.howItWorks.step1": "Al iniciar, <code>EywaGeminiLive.ts</code> obtiene memorias recientes y el destino de Supabase",
  "spectacles.voiceInterface.howItWorks.step2": "Ese contexto se convierte en las instrucciones del sistema de Gemini (\"Eres Eywa, un asistente de voz para navegar un enjambre de agentes\")",
  "spectacles.voiceInterface.howItWorks.step3": "El audio del micrófono se transmite a Gemini Live vía proxy WebSocket de Snap (no se necesita clave API)",
  "spectacles.voiceInterface.howItWorks.step4": "Gemini responde con audio (reproducido en las gafas) y transcripción de texto",
  "spectacles.voiceInterface.howItWorks.step5": "Las transcripciones se retransmiten a la web vía el canal de difusión (eventos <code>voice_input</code>, <code>voice_response</code>, <code>voice_inject</code>)",
  "spectacles.voiceInterface.howItWorks.step6": "Gemini tiene una herramienta <code>inject_message</code> que escribe directamente en la tabla de memorias de Supabase, haciendo el mensaje visible para todos los agentes en la sala",
  "spectacles.voiceInterface.broadcastEvents.heading": "Eventos de Difusión",
  "spectacles.voiceInterface.broadcastEvents.col.event": "Evento",
  "spectacles.voiceInterface.broadcastEvents.col.direction": "Dirección",
  "spectacles.voiceInterface.broadcastEvents.col.payload": "Payload",
  "spectacles.voiceInterface.broadcastEvents.col.description": "Descripción",
  "spectacles.voiceInterface.broadcastEvents.voiceInput.desc": "Transcripción de voz de usuario",
  "spectacles.voiceInterface.broadcastEvents.voiceResponse.desc": "Transcripción de respuesta Gemini",
  "spectacles.voiceInterface.broadcastEvents.voiceInject.desc": "Mensaje inyectado a sala",
  "spectacles.voiceInterface.testingWithout.heading": "Probar Sin Spectacles",
  "spectacles.voiceInterface.testingWithout.text": "Ejecuta la aplicación web y abre la página de transmisión de Spectacles. Luego simula eventos de voz desde la consola del navegador:",
  "spectacles.markerTracking.heading": "Rastreo de Marcador (Opcional)",
  "spectacles.markerTracking.text": "La escena usa Extended Marker Tracking para anclar opcionalmente el panel AR a una pantalla física. No se requiere un marcador. El panel aparece en una posición predeterminada automáticamente.",
  "spectacles.markerTracking.defaultMode.heading": "Modo Predeterminado (Sin Marcador)",
  "spectacles.markerTracking.defaultMode.step1": "Al lanzar, una protección de calentamiento de 2 segundos ignora detecciones falsas positivas de los primeros cuadros",
  "spectacles.markerTracking.defaultMode.step2": "Después de 3 segundos sin marcador detectado, el panel se auto-desprende a una posición predeterminada: 65cm hacia adelante, 3cm debajo del nivel de ojos",
  "spectacles.markerTracking.defaultMode.step3": "Si se detecta un marcador más tarde, el panel se reposiciona a la ubicación del marcador",
  "spectacles.markerTracking.defaultMode.step4": "El IMU de Spectacles maneja el rastreo de orientación después de la colocación",
  "spectacles.markerTracking.markerMode.heading": "Modo Marcador",
  "spectacles.markerTracking.markerMode.step1": "La cámara de Spectacles detecta el patrón del marcador de rastreo en una pantalla física",
  "spectacles.markerTracking.markerMode.step2": "El panel AR aparece en la posición del marcador (los hijos comienzan deshabilitados, habilitados en detección)",
  "spectacles.markerTracking.markerMode.step3": "Con <code>trackMarkerOnce: true</code>, el marcador se detecta una vez, el panel se desprende al espacio mundial, y el rastreo de marcador se deshabilita para ahorrar rendimiento",
  "spectacles.markerTracking.sceneHierarchy.heading": "Jerarquía de Escena",
  "spectacles.troubleshooting.heading": "Solución de Problemas",
  "spectacles.troubleshooting.snapCloud.heading": "\"SnapCloudRequirements no configurado\"",
  "spectacles.troubleshooting.snapCloud.text": "Asigna el asset SupabaseProject en el Inspector.",
  "spectacles.troubleshooting.noEvents.heading": "El canal se suscribe pero no llegan eventos",
  "spectacles.troubleshooting.noEvents.item1": "Verifica que los nombres de canal coincidan: web envía en <code>spectacles:&#123;slug&#125;:&#123;deviceId&#125;</code>, Spectacles se suscribe al mismo",
  "spectacles.troubleshooting.noEvents.item2": "Abre la consola del navegador en el lado web y verifica el estado \"SUBSCRIBED\"",
  "spectacles.troubleshooting.noEvents.item3": "El deviceId predeterminado es \"editor\" en ambos lados",
  "spectacles.troubleshooting.noTiles.heading": "Aparecen quads de prueba pero no tiles transmitidos",
  "spectacles.troubleshooting.noTiles.item1": "Habilita <code>showTestQuads</code> en Inspector para verificar el pipeline de mesh/material",
  "spectacles.troubleshooting.noTiles.item2": "Revisa Logger para mensajes de \"scene event\" o \"tex event\"",
  "spectacles.troubleshooting.noTiles.item3": "Si no hay eventos, la suscripción del canal podría estar fallando. Verifica errores de autenticación o red",
  "spectacles.troubleshooting.texturesDecode.heading": "Las texturas fallan al decodificar",
  "spectacles.troubleshooting.texturesDecode.item1": "La cadena base64 podría ser demasiado grande. Verifica la configuración de calidad JPEG en tileRenderers.ts",
  "spectacles.troubleshooting.texturesDecode.item2": "Supabase Realtime tiene un límite de mensaje de ~1MB. Las texturas de tiles individuales son típicamente 5-15KB",
  "spectacles.troubleshooting.wrongSize.heading": "Quads visibles pero tamaño o posición incorrectos",
  "spectacles.troubleshooting.wrongSize.item1": "<code>pixelsPerCm</code> controla el escalado: width_cm = pixel_width / pixelsPerCm",
  "spectacles.troubleshooting.wrongSize.item2": "Las posiciones están en cm, centradas en el origen del panel",
  "spectacles.troubleshooting.wrongSize.item3": "Desplazamientos Z de capa: 0=0.05cm, 1=1.5cm, 2=2.5cm, 3=3.5cm",
  "spectacles.ergonomics.heading": "Ergonomía",
  "spectacles.ergonomics.col.parameter": "Parámetro",
  "spectacles.ergonomics.col.value": "Valor",
  "spectacles.ergonomics.comfortDistance": "Distancia de confort",
  "spectacles.ergonomics.comfortRectangle": "Rectángulo de confort",
  "spectacles.ergonomics.defaultTile": "Tile predeterminado",
  "spectacles.ergonomics.bodyTextMin": "Texto de cuerpo mínimo",
  "spectacles.ergonomics.tapTargetMin": "Objetivo de toque mínimo",
  "spectacles.dependencies.heading": "Dependencias",
  "spectacles.dependencies.lensStudio": "Lens Studio (última versión)",
  "spectacles.dependencies.interactionKit": "SpectaclesInteractionKit.lspkg (rastreo de manos, pinch, Interactable)",
  "spectacles.dependencies.supabaseClient": "SupabaseClient.lspkg (SDK de Supabase de Snap para Lens Studio)",
  "spectacles.dependencies.supabaseProject": "Proyecto Supabase con Realtime habilitado",
  "selfHosting.title": "Alojamiento Propio",
  "selfHosting.lead": "Eywa es completamente código abierto. Puedes ejecutar tu propia instancia con Supabase para la base de datos, un Cloudflare Worker para el servidor MCP y Vite para el panel.",
  "selfHosting.database.heading": "1. Base de Datos (Supabase)",
  "selfHosting.database.intro": "Supabase proporciona PostgreSQL con suscripciones Realtime integradas. El panel y todas las integraciones dependen de Realtime para actualizaciones en vivo.",
  "selfHosting.database.step1": "Crea un proyecto en <a href=\"https://supabase.com\" target=\"_blank\" rel=\"noopener noreferrer\">supabase.com</a>",
  "selfHosting.database.step2": "Abre el SQL Editor y ejecuta el contenido de <code>schema.sql</code>",
  "selfHosting.database.step3": "Habilita Realtime para las tablas <code>memories</code> y <code>messages</code>. Ve a Database &gt; Replication, luego activa Realtime para ambas tablas.",
  "selfHosting.database.step4": "Copia tu URL de proyecto y clave de rol de servicio de Settings &gt; API. Necesitarás ambas para el worker y el panel.",
  "selfHosting.schema.heading": "Resumen del esquema",
  "selfHosting.schema.description": "El esquema define cinco tablas: <code>rooms</code> (espacios de trabajo), <code>memories</code> (toda actividad de agentes), <code>messages</code> (chat de equipo), <code>links</code> (conexiones entre sesiones) y <code>global_insights</code> (conocimiento de red anonimizado). La tabla <code>memories</code> es el núcleo de Eywa. Todo lo que los agentes registran, desde eventos de sesión hasta entradas de conocimiento hasta actualizaciones de destino, va aquí con una columna <code>metadata</code> JSONB para etiquetas estructuradas.",
  "selfHosting.worker.heading": "2. Servidor MCP (Cloudflare Worker)",
  "selfHosting.worker.intro": "El servidor MCP se ejecuta como un Cloudflare Worker sin estado que traduce llamadas de herramientas MCP en consultas PostgREST de Supabase. Usa HTTP fetch puro, no el SDK JS de Supabase.",
  "selfHosting.worker.endpointNote": "Después de desplegar, tu endpoint MCP estará disponible en la URL impresa por wrangler. Los agentes se conectan a <code>https://your-worker.workers.dev/mcp?room=my-team&amp;agent=claude/alice</code>.",
  "selfHosting.worker.localDev.heading": "Desarrollo local",
  "selfHosting.worker.localDev.description": "Para pruebas locales, usa <code>npx wrangler dev</code> en lugar de deploy. El worker iniciará en <code>http://localhost:8787</code>. Establece variables de entorno en <code>wrangler.toml</code> bajo <code>[vars]</code> para desarrollo local, o usa <code>.dev.vars</code> para secretos.",
  "selfHosting.dashboard.heading": "3. Panel (React/Vite)",
  "selfHosting.dashboard.intro": "El panel web es una aplicación React 19 construida con Vite. Se conecta directamente a Supabase usando el SDK JS y se suscribe a canales Realtime para actualizaciones en vivo.",
  "selfHosting.dashboard.envInstruction": "Edita <code>.env</code> con tus credenciales de Supabase y clave API de Gemini:",
  "selfHosting.dashboard.installAndRun": "Luego instala y ejecuta:",
  "selfHosting.dashboard.geminiNote": "La clave API de Gemini es opcional. Sin ella, el panel de dirección Gemini en el panel estará deshabilitado, pero todo lo demás funciona normalmente.",
  "selfHosting.discord.heading": "4. Bot de Discord (opcional)",
  "selfHosting.discord.intro": "El bot de Discord proporciona 15 comandos slash para observabilidad de equipo desde el chat. Se conecta directamente a Supabase, no a través del servidor MCP.",
  "selfHosting.discord.envInstruction": "Edita <code>.env</code> con tu token de bot de Discord y credenciales de Supabase:",
  "selfHosting.discord.installAndStart": "Luego instala, despliega comandos e inicia:",
  "selfHosting.discord.commands.heading": "Comandos disponibles",
  "selfHosting.discord.commands.help": "<code>/help</code> - Mostrar todos los comandos",
  "selfHosting.discord.commands.room": "<code>/room</code> - Ver o establecer la sala actual",
  "selfHosting.discord.commands.status": "<code>/status</code> - Vista general del estado de agentes",
  "selfHosting.discord.commands.agents": "<code>/agents</code> - Listar todos los agentes en la sala",
  "selfHosting.discord.commands.context": "<code>/context</code> - Contexto compartido reciente",
  "selfHosting.discord.commands.search": "<code>/search</code> - Buscar memorias de agentes",
  "selfHosting.discord.commands.recall": "<code>/recall</code> - Recordar mensajes de un agente específico",
  "selfHosting.discord.commands.inject": "<code>/inject</code> - Enviar contexto a un agente",
  "selfHosting.discord.commands.inbox": "<code>/inbox</code> - Verificar inyecciones pendientes",
  "selfHosting.discord.commands.knowledge": "<code>/knowledge</code> - Explorar la base de conocimiento",
  "selfHosting.discord.commands.learn": "<code>/learn</code> - Almacenar nuevo conocimiento",
  "selfHosting.discord.commands.msg": "<code>/msg</code> - Enviar un mensaje a la sala",
  "selfHosting.discord.commands.destination": "<code>/destination</code> - Ver o establecer el destino del equipo",
  "selfHosting.discord.commands.course": "<code>/course</code> - Verificar progreso hacia el destino",
  "selfHosting.discord.commands.network": "<code>/network</code> - Consultar la red global de insights",
  "selfHosting.vscode.heading": "5. Extensión VS Code (opcional)",
  "selfHosting.vscode.description": "La extensión VS Code muestra una barra lateral de árbol de agentes, feed de actividad, inyección de contexto y lente de conocimiento. Consulta <code>vscode-extension/</code> para instrucciones de construcción.",
  "selfHosting.updateMcpUrl.heading": "Actualizar la URL MCP",
  "selfHosting.updateMcpUrl.description": "Después de desplegar tu propio worker, actualiza la URL MCP en las configuraciones de tus agentes para que apunten a tu worker en lugar de la versión alojada. Reemplaza <code>mcp.eywa-ai.dev</code> con la URL de tu worker:",
  "pi.title": "Pantallas Pi",
  "pi.lead": "Scripts de Raspberry Pi para pantallas físicas de Eywa. Dos opciones de hardware sirven roles diferentes: la pantalla e-ink actúa como un tablero de estado ambiental y ancla de rastreo AR, mientras que la pantalla táctil TFT proporciona interacción directa con agentes. Si no tienes un Pi, cualquier dispositivo con navegador funciona como respaldo.",
  "pi.hardware.heading": "Hardware",
  "pi.hardware.table.display": "Pantalla",
  "pi.hardware.table.resolution": "Resolución",
  "pi.hardware.table.type": "Tipo",
  "pi.hardware.table.script": "Script",
  "pi.hardware.table.waveshare.name": "Waveshare 5.65\" 7-Color ACeP",
  "pi.hardware.table.waveshare.type": "E-Ink (pasivo)",
  "pi.hardware.table.tft.name": "3.5\" ILI9341 TFT",
  "pi.hardware.table.tft.type": "LCD (táctil)",
  "pi.displayStrategy.heading": "Estrategia de Pantalla",
  "pi.displayStrategy.eink.heading": "E-ink (superficie mate) - ancla AR + estado ambiental",
  "pi.displayStrategy.eink.matteTracking": "El e-ink mate tiene cero reflejos, haciéndolo confiable para rastreo de imagen de Spectacles",
  "pi.displayStrategy.eink.fixedMarker": "Un marcador de rastreo fijo en el lado derecho de la pantalla ancla la UI AR a la pantalla física",
  "pi.displayStrategy.eink.noTouch": "Sin entrada táctil. Los Spectacles proporcionan interacción vía rastreo de manos y gestos de pinch",
  "pi.displayStrategy.eink.refresh": "Se actualiza cada 5 minutos por defecto (configurable vía <code>--interval</code>) con estado de agentes, información de sala y marcador de rastreo",
  "pi.displayStrategy.eink.lowPower": "Bajo consumo. Funciona por horas con un banco de batería.",
  "pi.displayStrategy.tft.heading": "TFT táctil (LCD brillante) - superficie de control interactiva",
  "pi.displayStrategy.tft.noTracking": "Sin marcador de rastreo. Las pantallas brillantes causan reflejos que rompen el rastreo de imagen",
  "pi.displayStrategy.tft.directTouch": "Interacción táctil directa: toca agentes, envía inyecciones, explora memorias",
  "pi.displayStrategy.tft.refreshRate": "Tasa de actualización más alta (30fps) para UI responsiva",
  "pi.displayStrategy.tft.useCase": "Usado cuando quieres interactuar con agentes sin Spectacles",
  "pi.wiring.heading": "Cableado",
  "pi.wiring.eink.heading": "E-Ink (Waveshare HAT)",
  "pi.wiring.eink.description": "Solo conecta el HAT al encabezado GPIO del Pi. No se necesita cableado adicional. Para módulos independientes (sin HAT), usa el diagrama interactivo a continuación para ver qué pines conectar.",
  "pi.wiring.eink.moduleHeading": "Cableado del Módulo Waveshare",
  "pi.wiring.eink.moduleHint": "Selecciona un tipo de dispositivo para ver sus conexiones GPIO. Pasa el mouse sobre cualquier pin para trazar el cable.",
  "pi.wiring.tft.heading": "TFT (ILI9341 3.5\" + XPT2046 Touch)",
  "pi.wiring.tft.description": "La pantalla ILI9341 y el controlador táctil XPT2046 comparten el bus SPI. Alterna las capas LCD y táctil independientemente para ver qué pines se comparten.",
  "pi.einkSetup.heading": "Configuración E-Ink (Waveshare 5.65\" ACeP)",
  "pi.einkSetup.step1.heading": "1. Habilitar SPI en Pi",
  "pi.einkSetup.step2.heading": "2. Instalar Biblioteca Waveshare",
  "pi.einkSetup.step3.heading": "3. Instalar Dependencias Python",
  "pi.einkSetup.step4.heading": "4. Establecer Entorno",
  "pi.einkSetup.step5.heading": "5. Ejecutar",
  "pi.einkSetup.step6.heading": "6. Auto-iniciar al Arrancar (systemd)",
  "pi.tftSetup.heading": "Configuración TFT Touch (ILI9341 3.5\")",
  "pi.tftSetup.step1.heading": "1. Habilitar SPI + Instalar fbcp",
  "pi.tftSetup.step2.heading": "2. Ejecutar Interfaz Táctil",
  "pi.fallback.heading": "Respaldo de Mini Pantalla (Teléfono/Tableta/Web)",
  "pi.fallback.intro": "Si no tienes un Raspberry Pi, puedes usar cualquier dispositivo con navegador como pantalla. El panel web incluye vistas optimizadas para pantalla.",
  "pi.fallback.eink.heading": "MiniEywaEink (modo ambiental)",
  "pi.fallback.eink.description": "Navega a <code>/r/&#123;room-slug&#125;</code> y selecciona la vista e-ink. Renderiza un diseño estático con nombre de sala, avatares de agentes y estado, feed de actividad y código QR de sala. Útil para un teléfono apoyado en un escritorio, una tableta vieja montada en una pared, o un Raspberry Pi ejecutando Chromium en modo kiosko.",
  "pi.fallback.spectacles.heading": "SpectaclesView (transmisión AR)",
  "pi.fallback.spectacles.description": "Navega a <code>/r/&#123;room-slug&#125;/spectacles</code> y haz clic en \"Broadcast\". Esto renderiza texturas de tiles y las transmite a Spectacles conectados vía Supabase Realtime.",
  "pi.testScripts.heading": "Scripts de Prueba",
  "pi.testScripts.intro": "Ejecuta estos después del cableado para verificar el hardware antes de usar las aplicaciones completas de Eywa.",
  "pi.testScripts.table.script": "Script",
  "pi.testScripts.table.whatItTests": "Qué Prueba",
  "pi.testScripts.table.displayNeeded": "¿Pantalla Necesaria?",
  "pi.testScripts.table.tft.tests": "Barras de color TFT, renderizado de texto, entrada táctil",
  "pi.testScripts.table.tft.display": "TFT (o <code>--window</code> para laptop)",
  "pi.testScripts.table.eink.tests": "Muestras de 7 colores e-ink, formas, cuadrícula de píxeles",
  "pi.testScripts.table.eink.display": "E-ink (o <code>--preview</code> para PNG, <code>--clear</code> para limpiar pantalla)",
  "pi.testScripts.table.touch.tests": "Eventos táctiles crudos, rangos de coordenadas, detección de dispositivo",
  "pi.testScripts.table.touch.display": "Ninguno (lee entrada del kernel)"
}
