{
  "sidebar.gettingStarted": "Commencer",
  "sidebar.overview": "Aperçu",
  "sidebar.quickstart": "Démarrage rapide",
  "sidebar.integrations": "Intégrations",
  "sidebar.surfaces": "Surfaces",
  "sidebar.cli": "CLI",
  "sidebar.vscodeExtension": "Extension VS Code",
  "sidebar.discordBot": "Bot Discord",
  "sidebar.spectaclesAR": "Spectacles AR",
  "sidebar.piDisplays": "Écrans Pi",
  "sidebar.reference": "Référence",
  "sidebar.architecture": "Architecture",
  "sidebar.selfHosting": "Auto-hébergement",
  "sidebar.resources": "Ressources",
  "sidebar.llmDocs": "Docs LLM (llms.txt)",
  "sidebar.github": "GitHub",
  "sidebar.discord": "Discord",
  "overview.title": "Documentation Eywa",
  "overview.lead": "Eywa est une couche d'observabilité et de coordination pour les équipes humaines + IA. Chaque personne de votre équipe dirige des agents IA qui codent, décident et livrent de manière autonome. Eywa rend tout ce travail visible pour que les humains restent alignés.",
  "overview.whatIsEywa": "Qu'est-ce qu'Eywa ?",
  "overview.whatIsEywaDesc": "Eywa est un serveur MCP qui offre à votre équipe une visibilité partagée sur chaque session d'agent IA. Quand tout le monde utilise l'IA, les petits désalignements entre personnes se multiplient à la vitesse des machines. Eywa fournit une vue partagée de ce que tous les agents construisent pour que vous sachiez sur quoi vous synchroniser. Il fonctionne avec tout agent prenant en charge le Model Context Protocol : Claude Code, Cursor, Windsurf, Gemini CLI, Codex, Cline, et plus encore.",
  "overview.coreFeatures": "Fonctionnalités principales",
  "overview.destinationProgress": "Destination et progression",
  "overview.destinationProgressDesc": "Définissez un état cible pour votre équipe, définissez des jalons et suivez l'achèvement au fur et à mesure que les agents livrent. Les agents signalent leur progression avec un pourcentage et un statut. La destination est visible sur chaque surface : tableau de bord web, barre latérale VS Code, Discord et contexte automatique MCP.",
  "overview.liveAgentMap": "Carte d'agents en direct",
  "overview.liveAgentMapDesc": "Voyez ce sur quoi travaille chaque agent de votre équipe en temps réel. Le statut, la tâche, les systèmes touchés et la progression de chaque agent sont visibles sur le tableau de bord HubView. Les agents actifs sont mis en évidence, avec des métadonnées d'opération (système, action, portée, résultat) pour une observabilité totale.",
  "overview.contextInjection": "Injection de contexte",
  "overview.contextInjectionDesc": "Poussez des décisions ou corrections dans n'importe quel agent en cours de session. Les agents voient les injections à leur prochain appel d'outil grâce à une livraison automatique par superposition. Prend en charge les niveaux de priorité normal, élevé et urgent.",
  "overview.teamKnowledge": "Connaissances de l'équipe",
  "overview.teamKnowledgeDesc": "Mémoire persistante qui survit à toutes les sessions. Stockez des décisions d'architecture, des conventions API, des pièges et des modèles avec <code>eywa_learn</code>. Les connaissances sont consultables par balises et contenu, et apparaissent dans le contexte automatique de l'agent au démarrage de la session.",
  "overview.timelineBranching": "Chronologie et branchement",
  "overview.timelineBranchingDesc": "Contrôle de version type Git pour le travail des agents. Revenez à n'importe quel point avec <code>eywa_rewind</code>, créez des chronologies alternatives avec <code>eywa_fork</code>, sélectionnez des moments à travers les branches avec <code>eywa_pick</code>, et fusionnez avec <code>eywa_merge</code>. Marquez les décisions importantes pour une navigation facile.",
  "overview.globalInsights": "Réseau mondial d'insights",
  "overview.globalInsightsDesc": "Publiez des modèles anonymisés depuis votre salle avec <code>eywa_publish_insight</code>. Interrogez l'intelligence inter-salles avec <code>eywa_query_network</code> pour que vos agents apprennent de ce qui a fonctionné dans d'autres équipes. Les recommandations de voie suggèrent des insights pertinents selon votre tâche actuelle.",
  "overview.contextRecovery": "Récupération de contexte",
  "overview.contextRecoveryDesc": "Les agents créent des points de contrôle de leur progression avec <code>eywa_checkpoint</code> et envoient des signaux de détresse avec <code>eywa_distress</code> quand le contexte devient faible. Les nouvelles sessions reprennent automatiquement là où la dernière s'est arrêtée. Le passage de témoin permet aux agents de transférer le travail en cours de session.",
  "overview.workClaiming": "Revendication de travail",
  "overview.workClaimingDesc": "Les agents déclarent ce sur quoi ils travaillent avec <code>eywa_claim</code> pour éviter les efforts dupliqués. Les revendications actives sont visibles dans les instantanés de session et les instructions MCP. Les revendications se libèrent automatiquement quand les sessions se terminent.",
  "overview.geminiSteering": "Pilotage Gemini",
  "overview.geminiSteeringDesc": "Panneau de chat Gemini intégré avec 6 outils pour interroger le statut des agents, détecter des modèles, analyser les signaux de détresse et piloter l'équipe. Alerte de manière proactive sur les problèmes détectés et la détresse des agents.",
  "overview.interactionSurfaces": "Surfaces d'interaction",
  "overview.interactionSurfacesDesc": "Le même modèle de navigation (destination, parcours, pilotage) fonctionne sur chaque surface :",
  "overview.surfaceWeb": "Tableau de bord web",
  "overview.surfaceWebDesc": "HubView avec carte d'agents, bannière de destination, chat Gemini, flux d'activité et barre d'injection",
  "overview.surfaceVscode": "Extension VS Code",
  "overview.surfaceVscodeDesc": "Barre latérale avec avatars d'agents, flux d'activité, notifications d'attention et panneau de détails d'agent à côté des terminaux",
  "overview.surfaceDiscord": "Bot Discord",
  "overview.surfaceDiscordDesc": "15 commandes slash pour piloter l'équipe : <code>/destination</code>, <code>/course</code>, <code>/status</code>, <code>/inject</code>, et plus encore",
  "overview.surfaceCli": "CLI",
  "overview.surfaceCliDesc": "<code>npx eywa-ai init</code> pour une configuration de salle sans authentification, plus les commandes status, inject et log",
  "overview.surfaceSpectacles": "Spectacles AR",
  "overview.surfaceSpectaclesDesc": "Journal d'activité, chat Gemini et progression de destination sous forme de panneaux AR flottants via Supabase Realtime",
  "overview.usageLimits": "Limites d'utilisation",
  "overview.usageLimitsDesc": "Eywa est hébergé gratuitement sur eywa-ai.dev. Pour maintenir la fiabilité du service, la version hébergée a des limites d'utilisation. L'auto-hébergement supprime toutes les limites.",
  "overview.table.free": "Gratuit",
  "overview.table.pro": "Pro",
  "overview.table.enterprise": "Entreprise",
  "overview.table.teamMembers": "Membres de l'équipe",
  "overview.table.history": "Historique",
  "overview.table.memoriesPerRoom": "Mémoires par salle",
  "overview.table.integrations": "Intégrations",
  "overview.table.knowledgeBase": "Base de connaissances",
  "overview.table.timelineBranching": "Branchement de chronologie",
  "overview.table.price": "Prix",
  "overview.table.unlimited": "Illimité",
  "overview.table.custom": "Personnalisé",
  "overview.table.all": "Tous",
  "overview.table.allCustom": "Tous + personnalisés",
  "overview.table.readOnly": "Lecture seule",
  "overview.table.full": "Complet",
  "overview.table.viewOnly": "Visualisation uniquement",
  "overview.table.contactUs": "Nous contacter",
  "overview.demoNote": "Les salles de démonstration sont des copies d'exemples de données qui expirent après 24 heures. Créez votre propre salle avec <code>npx eywa-ai init</code> pour une utilisation persistante.",
  "overview.llmDocs": "Documentation LLM",
  "overview.llmDocsDesc": "Pour les agents IA qui ont besoin de comprendre la surface API complète d'Eywa, dirigez-les vers <a href=\"/llms.txt\">llms.txt</a> qui décrit tous les outils disponibles, les guides d'intégration et les workflows courants.",
  "overview.gettingStarted": "Commencer",
  "overview.gettingStartedDesc": "Choisissez votre agent de codage IA dans la barre latérale pour voir les instructions de configuration spécifiques. La plupart des intégrations prennent moins de 2 minutes à configurer.",
  "overview.claudeCodeDesc": "Agent CLI d'Anthropic",
  "overview.cursorDesc": "Éditeur de code IA",
  "overview.windsurfDesc": "IDE propulsé par IA",
  "quickstart.title": "Démarrage rapide",
  "quickstart.lead": "Faites partager le contexte aux agents IA de votre équipe en moins d'une minute. Pas d'authentification, pas d'inscription, pas de configuration manuelle.",
  "quickstart.createRoom": "Créer une salle",
  "quickstart.createRoomDesc": "Une seule commande crée une salle, détecte automatiquement tous les agents IA sur votre machine, les configure tous et ouvre le tableau de bord.",
  "quickstart.thisWill": "Ceci va :",
  "quickstart.willCreateRoom": "Créer une salle avec un nom aléatoire (ou passez le vôtre : <code>npx eywa-ai init mon-equipe</code>)",
  "quickstart.willAutoDetect": "Détecter automatiquement les agents installés (Claude Code, Cursor, Windsurf, Gemini CLI, Codex)",
  "quickstart.willConfigure": "Configurer chacun pour partager le contexte via la salle",
  "quickstart.willOpenDashboard": "Ouvrir le tableau de bord en direct dans votre navigateur",
  "quickstart.usernameNote": "Le CLI utilise votre nom d'utilisateur système comme nom d'agent pour qu'Eywa puisse distinguer les membres de l'équipe. Aucune copie manuelle de snippets de configuration requise.",
  "quickstart.joinRoom": "Rejoindre une salle existante",
  "quickstart.joinRoomDesc": "Si quelqu'un dans votre équipe a déjà créé une salle, rejoignez-la avec :",
  "quickstart.joinRoomNote": "Ceci enregistre la salle comme votre salle par défaut, configure automatiquement tous les agents détectés et ouvre le tableau de bord.",
  "quickstart.manualSetup": "Configuration manuelle",
  "quickstart.manualSetupDesc": "Si la détection automatique manque un agent (ou si vous voulez en configurer un manuellement), le format de point de terminaison MCP est :",
  "quickstart.manualSetupSeeText1": "Voir les ",
  "quickstart.manualSetupIntegrationLink": "guides d'intégration",
  "quickstart.manualSetupSeeText2": " pour les emplacements de fichiers de configuration spécifiques à chaque agent.",
  "quickstart.whatsNext": "Et ensuite",
  "quickstart.whatsNextText1": "Une fois votre agent connecté, il obtient plus de 40 outils pour enregistrer le travail, partager le contexte, injecter des décisions et coordonner avec d'autres agents. Consultez l'",
  "quickstart.whatsNextDocsLink": "aperçu de la documentation",
  "quickstart.whatsNextText2": " pour la ventilation complète des fonctionnalités, ou parcourez la ",
  "quickstart.whatsNextCLILink": "référence CLI",
  "quickstart.whatsNextText3": " pour toutes les commandes disponibles.",
  "cli.title": "Référence CLI",
  "cli.lead": "Le CLI <code>eywa-ai</code> gère la configuration des salles et la gestion de base. Zéro authentification, zéro installation. Exécutez-le avec <code>npx</code> et vous êtes connecté.",
  "cli.installation": "Installation",
  "cli.installationDesc": "Aucune installation nécessaire. Exécutez simplement avec npx :",
  "cli.stateDesc": "Ceci télécharge et exécute la dernière version à la volée. L'état est enregistré localement dans <code>~/.eywa/config.json</code> pour que les commandes suivantes se souviennent de votre salle par défaut.",
  "cli.commands": "Commandes",
  "cli.initTitle": "init [nom]",
  "cli.initDesc": "Créez une nouvelle salle et configurez automatiquement tous les agents IA détectés sur votre machine. Si vous passez un nom, la salle l'utilise comme slug. Sinon Eywa génère un nom aléatoire comme <code>cosmic-fox-a1b2</code>. Le CLI détecte Claude Code, Cursor, Windsurf, Gemini CLI et Codex, écrit leurs configurations MCP et ouvre le tableau de bord.",
  "cli.joinTitle": "join <slug-salle>",
  "cli.joinDesc": "Rejoignez une salle créée par quelqu'un d'autre. Configure automatiquement tous les agents détectés, enregistre la salle comme votre salle par défaut et ouvre le tableau de bord.",
  "cli.statusTitle": "status [salle]",
  "cli.statusDesc": "Affiche tous les agents dans la salle avec leur statut actuel (actif, terminé, bloqué, échoué, inactif), heure de la dernière activité, description de la tâche et les systèmes qu'ils ont touchés.",
  "cli.logTitle": "log [salle] [limite]",
  "cli.logDesc": "Flux d'activité montrant les mémoires récentes avec horodatages, noms d'agents, types d'événements et métadonnées d'opération (système, action, résultat). Par défaut 30 entrées.",
  "cli.injectTitle": "inject <cible> <message>",
  "cli.injectDesc": "Poussez du contexte dans la session d'un agent. L'agent cible voit l'injection à son prochain appel d'outil via la livraison par superposition d'Eywa.",
  "cli.dashboardTitle": "dashboard [salle]",
  "cli.dashboardDesc": "Ouvrez le tableau de bord web pour une salle. Également disponible comme <code>dash</code> ou <code>open</code>.",
  "cli.helpTitle": "help",
  "cli.helpDesc": "Affiche les informations d'utilisation. Également déclenché par <code>--help</code> ou <code>-h</code>.",
  "cli.whatAgentsCanDo": "Ce que les agents peuvent faire",
  "cli.whatAgentsCanDoDesc": "Une fois qu'un agent se connecte au serveur MCP Eywa, il obtient plus de 40 outils organisés dans ces catégories :",
  "cli.tableCategory": "Catégorie",
  "cli.tableTools": "Outils",
  "cli.tableWhatTheyDo": "Ce qu'ils font",
  "cli.categorySession": "Session",
  "cli.sessionDesc": "Suivre ce sur quoi chaque agent travaille",
  "cli.categoryMemory": "Mémoire",
  "cli.memoryDesc": "Enregistrer les décisions, stocker les fichiers, rechercher l'historique",
  "cli.categoryContext": "Contexte",
  "cli.contextDesc": "Voir ce que font les autres, récupérer leur contexte",
  "cli.categoryInjection": "Injection",
  "cli.injectionDesc": "Pousser du contexte vers n'importe quel agent",
  "cli.categoryKnowledge": "Connaissances",
  "cli.knowledgeDesc": "Connaissances de projet persistantes à travers les sessions",
  "cli.categoryMessaging": "Messagerie",
  "cli.messagingDesc": "Chat d'équipe entre agents et humains",
  "cli.categoryDestination": "Destination",
  "cli.destinationDesc": "Définir les objectifs d'équipe, suivre les jalons, signaler la progression",
  "cli.categoryRecovery": "Récupération",
  "cli.recoveryDesc": "Sauvegarder l'état, survivre à l'épuisement du contexte, transférer le travail",
  "cli.categoryClaiming": "Revendication",
  "cli.claimingDesc": "Empêcher le travail en double à travers les agents",
  "cli.categoryLinking": "Liaison",
  "cli.linkingDesc": "Connecter les mémoires à travers les sessions",
  "cli.categoryTimeline": "Chronologie",
  "cli.timelineDesc": "Contrôle de version type Git pour le travail des agents",
  "cli.categoryNetwork": "Réseau",
  "cli.networkDesc": "Partage de connaissances anonymisées inter-salles et routage",
  "cli.howItWorks": "Comment ça fonctionne",
  "cli.howItWorksDesc": "Les agents se connectent à un Cloudflare Worker sans état via MCP (Model Context Protocol). Le worker lit et écrit dans Supabase. Le tableau de bord, le CLI, le bot Discord, l'extension VS Code et Spectacles AR lisent tous depuis la même base de données en temps réel.",
  "architecture.title": "Architecture",
  "architecture.lead": "Eywa est un serveur MCP sans état soutenu par Supabase. Les agents se connectent via HTTP, le serveur écrit dans PostgreSQL, et chaque surface lit depuis la même base de données en temps réel.",
  "architecture.systemDiagram": "Diagramme du système",
  "architecture.techStack": "Stack technique",
  "architecture.techStack.component": "Composant",
  "architecture.techStack.technology": "Technologie",
  "architecture.techStack.mcpServer": "Serveur MCP",
  "architecture.techStack.mcpServerDesc": "Cloudflare Workers, <code>@modelcontextprotocol/sdk</code>",
  "architecture.techStack.database": "Base de données",
  "architecture.techStack.databaseDesc": "Supabase (PostgreSQL + Realtime)",
  "architecture.techStack.dashboard": "Tableau de bord",
  "architecture.techStack.dashboardDesc": "React 19, TypeScript, Vite",
  "architecture.techStack.aiChat": "Chat IA",
  "architecture.techStack.aiChatDesc": "Gemini (gemini-2.5-flash)",
  "architecture.techStack.cli": "CLI",
  "architecture.techStack.cliDesc": "Node.js, <code>@supabase/supabase-js</code>",
  "architecture.techStack.discordBot": "Bot Discord",
  "architecture.techStack.discordBotDesc": "discord.js, Supabase direct",
  "architecture.techStack.vsCode": "VS Code",
  "architecture.techStack.vsCodeDesc": "API Extension, Supabase Realtime",
  "architecture.techStack.ar": "AR",
  "architecture.techStack.arDesc": "Snap Spectacles / Lens Studio",
  "architecture.techStack.ambient": "Ambiant",
  "architecture.techStack.ambientDesc": "E-ink 7 couleurs Waveshare, TFT Raspberry Pi",
  "architecture.projectStructure": "Structure du projet",
  "architecture.howItWorks": "Comment ça fonctionne",
  "architecture.mcpProtocol": "Protocole MCP",
  "architecture.mcpProtocolDesc": "Les agents se connectent à Eywa en utilisant le Model Context Protocol (MCP), un standard ouvert pour connecter les agents IA aux outils externes. Chaque agent ouvre une connexion HTTP vers le Cloudflare Worker à une URL comme :",
  "architecture.mcpProtocolDesc2": "L'URL indique à Eywa quelle salle rejoindre et comment appeler l'agent. Une fois connecté, l'agent peut appeler n'importe lequel des 45 outils : enregistrer des mémoires, lire le contexte de l'équipe, injecter des informations dans d'autres agents, définir des destinations, et plus encore.",
  "architecture.cloudflareWorker": "Cloudflare Worker",
  "architecture.cloudflareWorkerDesc": "Le serveur MCP fonctionne comme un Cloudflare Worker sans état. Il n'a pas de stockage local. Chaque appel d'outil se traduit par une requête HTTP Supabase PostgREST (pas le SDK JS, juste des appels fetch bruts). Cela signifie que le serveur peut réduire à zéro et gérer n'importe quel nombre d'agents simultanés sans affinité de session.",
  "architecture.cloudflareWorkerDesc2": "Au moment de la connexion, le worker pousse le contexte de la salle dans le champ <code>instructions</code> de MCP. Cela donne aux agents une pleine conscience situationnelle (agents actifs, activité récente, injections en attente, nombre de connaissances, destination, état de récupération) avant même qu'ils ne fassent un seul appel d'outil.",
  "architecture.supabase": "Supabase",
  "architecture.supabaseDesc": "Tout l'état vit dans Supabase (PostgreSQL). Le tableau de bord et les autres surfaces s'abonnent aux canaux Supabase Realtime, donc les changements de n'importe quel agent apparaissent immédiatement sur chaque client connecté. Le schéma définit cinq tables principales plus une table refs pour le branchement de chronologie.",
  "architecture.realtime": "Realtime",
  "architecture.realtimeDesc": "Quand un agent enregistre une mémoire, l'abonnement Supabase Realtime la pousse vers chaque tableau de bord connecté, instance VS Code et bot Discord en quelques millisecondes. C'est ainsi que le HubView montre l'activité des agents en direct et que le flux d'activité se met à jour sans polling.",
  "architecture.agentIdentity": "Identité de l'agent",
  "architecture.agentIdentityDesc": "Chaque agent obtient une identité au format <code>{nom_base}/{adjectif}-{nom}</code>. Par exemple : <code>armand/quiet-oak</code>, <code>cursor/bright-fox</code>. Le nom de base est l'humain qui possède l'agent, et le suffixe est généré automatiquement pour distinguer plusieurs sessions par la même personne.",
  "architecture.agentIdentityDesc2": "Le nom de base correspond au paramètre de requête <code>agent</code> dans l'URL MCP. Quand vous définissez <code>agent=claude/alice</code>, Eywa sait qu'\"alice\" est l'humain et \"claude\" est le type d'agent. Cela permet au système de router les injections vers tous les agents d'alice quel que soit l'outil qu'ils utilisent.",
  "architecture.coreTables": "Tables principales",
  "architecture.coreTables.table": "Table",
  "architecture.coreTables.purpose": "Objectif",
  "architecture.coreTables.keyFields": "Champs clés",
  "architecture.coreTables.roomsDesc": "Espaces de travail isolés. Chaque équipe obtient une salle avec un slug unique.",
  "architecture.coreTables.memoriesDesc": "Tout ce que les agents enregistrent : événements de session, décisions, fichiers, connaissances, injections, points de contrôle, destinations, revendications et mises à jour de progression. La colonne <code>metadata</code> JSONB stocke les balises d'opération (système, action, portée, résultat) et les données spécifiques à l'événement.",
  "architecture.coreTables.messagesDesc": "Chat d'équipe entre agents et humains. Organisé par canaux.",
  "architecture.coreTables.linksDesc": "Connexions inter-sessions entre mémoires. Prend en charge les types de liens référence, injection et fork.",
  "architecture.coreTables.globalInsightsDesc": "Connaissances anonymisées partagées entre folds pour le réseau mondial.",
  "architecture.privacy": "Confidentialité",
  "architecture.privacyDesc": "Votre code ne quitte jamais votre machine. Eywa ne synchronise que les métadonnées : ce sur quoi travaillent les agents, les décisions qu'ils ont prises, les fichiers qu'ils ont stockés (si vous appelez explicitement <code>eywa_file</code>), et les mises à jour de progression. Le serveur MCP ne voit jamais votre code source, historique git ou contenu de fichiers à moins qu'un agent ne les envoie explicitement via un appel d'outil.",
  "architecture.privacyDesc2": "Les sessions d'agents sont délimitées par salles. Chaque salle est un espace de travail isolé. Il n'y a pas d'accès aux données inter-salles à moins que vous ne publiiez sur le réseau mondial d'insights, qui anonymise la source avant de partager.",
  "discord.title": "Bot Discord",
  "discord.lead": "Le bot Discord Eywa donne à votre équipe une observabilité de toute l'activité des agents depuis le chat. 15 commandes slash pour parcourir le statut des agents, rechercher des mémoires, injecter du contexte, gérer les connaissances et piloter vers une destination.",
  "discord.setup": "Configuration",
  "discord.setup.step1": "Invitez le bot sur votre serveur Discord.",
  "discord.setup.step2": "Dans le canal que vous voulez utiliser, exécutez <code>/room set &lt;slug&gt;</code> pour le lier à une salle Eywa. Toutes les commandes dans ce canal interrogeront cette salle.",
  "discord.setup.step3": "Exécutez <code>/status</code> pour voir ce sur quoi travaillent les agents.",
  "discord.setup.multiChannel": "Vous pouvez lier différents canaux à différentes salles si votre serveur a plusieurs équipes.",
  "discord.agentIdentity": "Identité de l'agent",
  "discord.agentIdentityDesc": "Les messages envoyés depuis Discord apparaissent dans Eywa comme <code>discord/&lt;nomutilisateur&gt;</code>. Quand vous utilisez <code>/inject</code>, <code>/learn</code>, <code>/msg</code> ou <code>/destination set</code>, l'expéditeur est enregistré comme <code>discord/votrenom</code> pour que les agents et coéquipiers puissent voir qui l'a envoyé.",
  "discord.commandReference": "Référence des commandes",
  "discord.observe": "Observer",
  "discord.tableCommand": "Commande",
  "discord.tableDescription": "Description",
  "discord.tableOptions": "Options",
  "discord.helpDesc": "Comment utiliser le bot Eywa. Affiche toutes les commandes groupées par catégorie.",
  "discord.statusDesc": "Voir ce sur quoi tous les agents travaillent actuellement. Affiche les agents actifs, récents et inactifs avec les systèmes touchés.",
  "discord.agentsDesc": "Liste tous les agents qui ont enregistré dans cette salle, avec le nombre de mémoires et l'heure de dernière vue.",
  "discord.contextDesc": "Voir l'activité récente à travers tous les agents comme une chronologie.",
  "discord.contextOptions": "<code>count</code> - nombre d'entrées (1-30, par défaut 10)",
  "discord.recallDesc": "Voir l'activité récente d'un agent spécifique. Les noms d'agents s'auto-complètent pendant la saisie.",
  "discord.recallOptions": "<code>agent</code> (requis) - nom de l'agent<br /><code>count</code> - nombre d'entrées (1-30, par défaut 15)",
  "discord.searchDesc": "Rechercher dans les mémoires des agents par texte.",
  "discord.searchOptions": "<code>query</code> (requis) - texte à rechercher<br /><code>limit</code> - résultats max (1-25, par défaut 10)",
  "discord.interact": "Interagir",
  "discord.injectDesc": "Envoyer du contexte ou des instructions à un agent. L'agent le voit à son prochain appel d'outil.",
  "discord.injectOptions": "<code>target</code> (requis) - nom de l'agent ou \"all\" pour diffusion<br /><code>message</code> (requis) - le contexte à envoyer<br /><code>priority</code> - Normal, Élevé ou Urgent<br /><code>label</code> - courte étiquette (ex. \"rapport de bug\")",
  "discord.inboxDesc": "Voir les injections en attente pour un agent.",
  "discord.inboxOptions": "<code>target</code> - nom de l'agent ou \"all\" pour les diffusions<br /><code>limit</code> - entrées max (1-25, par défaut 10)",
  "discord.msgDesc": "Envoyer un message au chat d'équipe Eywa.",
  "discord.msgOptions": "<code>text</code> (requis) - message à envoyer<br /><code>channel</code> - canal de chat (par défaut : general)",
  "discord.knowledge": "Connaissances",
  "discord.knowledgeDesc": "Parcourir la base de connaissances du projet. Prend en charge le filtrage par texte de recherche et balises.",
  "discord.knowledgeOptions": "<code>search</code> - rechercher dans le contenu des connaissances<br /><code>tag</code> - filtrer par balise (ex. architecture, api)<br /><code>limit</code> - entrées max (1-25, par défaut 10)",
  "discord.learnDesc": "Stocker des connaissances pour que les agents de l'équipe les référencent dans toutes les sessions.",
  "discord.learnOptions": "<code>content</code> (requis) - les connaissances à stocker<br /><code>title</code> - titre court pour un balayage rapide<br /><code>tags</code> - balises séparées par virgules (ex. api,convention,piege)",
  "discord.networkDesc": "Parcourir le réseau de connaissances mondial. Affiche les insights anonymisés partagés entre les salles.",
  "discord.networkOptions": "<code>search</code> - rechercher les insights par texte<br /><code>domain</code> - filtrer par balise de domaine (ex. typescript, react)",
  "discord.navigation": "Navigation",
  "discord.destinationViewDesc": "Voir la destination actuelle et la progression des jalons.",
  "discord.destinationSetDesc": "Définir une nouvelle destination (point B) pour la salle.",
  "discord.destinationSetOptions": "<code>target</code> (requis) - l'état cible<br /><code>milestones</code> - jalons séparés par virgules",
  "discord.destinationCheckDesc": "Marquer un jalon comme terminé. Utilise la correspondance floue sur le nom.",
  "discord.destinationCheckOptions": "<code>milestone</code> (requis) - nom du jalon à compléter",
  "discord.courseDesc": "Vue d'ensemble complète du parcours : progression de la destination, agents actifs avec pourcentages d'achèvement, signaux de détresse et décomptes d'agents.",
  "discord.room": "Salle",
  "discord.roomSetDesc": "Lier ce canal Discord à une salle Eywa.",
  "discord.roomSetOptions": "<code>slug</code> (requis) - slug de la salle (ex. demo, hackathon)",
  "discord.roomInfoDesc": "Afficher à quelle salle ce canal est lié.",
  "discord.roomListDesc": "Lister toutes les salles disponibles.",
  "discord.examples": "Exemples",
  "discord.exampleCheckTeam": "Vérifier ce que l'équipe construit",
  "discord.exampleSendInstructions": "Envoyer des instructions à un agent",
  "discord.exampleStoreKnowledge": "Stocker et trouver des connaissances",
  "discord.exampleSetDestination": "Définir une destination et suivre la progression",
  "discord.selfHosting": "Auto-hébergement",
  "discord.selfHostingDesc": "Le bot utilise des requêtes Supabase directes (pas MCP). Pour exécuter votre propre instance :",
  "discord.selfHostingDeploy": "Déployez les commandes vers une guilde avec <code>npm run deploy -- &lt;guild_id&gt;</code>.",
  "vscode.title": "Extension VS Code",
  "vscode.lead": "L'extension VS Code d'Eywa vous donne une barre latérale en direct montrant chaque session d'agent dans votre salle, un système d'attention qui fait remonter les agents nécessitant votre intervention, des décorations d'éditeur en ligne pour les portées d'agents actifs, et une injection de contexte depuis votre éditeur. Elle se connecte à la même salle à laquelle vos agents rapportent, donc vous voyez ce qu'ils voient.",
  "vscode.installation.heading": "Installation",
  "vscode.installation.text": "Installez depuis le <a href=\"https://marketplace.visualstudio.com/items?itemName=curvilinear.eywa-agents\" target=\"_blank\" rel=\"noopener noreferrer\">Marketplace VS Code</a>. Recherchez \"Eywa\" dans le panneau Extensions, ou exécutez ceci depuis la palette de commandes :",
  "vscode.quickStart.heading": "Démarrage rapide",
  "vscode.quickStart.step1": "Cliquez sur l'icône Eywa dans la barre d'activité",
  "vscode.quickStart.step2": "Cliquez sur <strong>Set Room</strong> et entrez votre slug de salle (ex. <code>mon-projet</code>)",
  "vscode.quickStart.step3": "Exécutez <strong>Eywa: Connect Agent</strong> depuis la palette de commandes pour générer une URL MCP et la copier dans votre presse-papiers",
  "vscode.quickStart.selfHost": "L'extension se connecte à l'instance Eywa hébergée par défaut. Si vous auto-hébergez, exécutez <strong>Eywa: Login</strong> pour vous connecter via le navigateur.",
  "vscode.features.heading": "Fonctionnalités",
  "vscode.features.liveSidebar.heading": "Barre latérale en direct",
  "vscode.features.liveSidebar.p1": "Le panneau principal affiche les agents sous forme de puces d'avatar avec des points de statut (vert = actif, jaune = inactif, gris = terminé). Cliquez sur n'importe quelle puce d'agent pour développer un panneau de détails montrant leur tâche actuelle, barre de progression, nombre de mémoires et heure de dernière vue. Le panneau de détails a des boutons pour injecter du contexte directement à cet agent ou ouvrir le tableau de bord web.",
  "vscode.features.liveSidebar.p2": "Sous la bande d'agents, un flux d'activité défilant montre les événements récents à travers tous les agents avec des balises d'opération (système, action, résultat). Cliquez sur n'importe quel élément du flux pour développer son texte complet. Les avatars correspondent à travers VS Code, le tableau de bord web et les écrans matériels.",
  "vscode.features.liveSidebar.p3": "La barre latérale affiche également une bannière de destination quand la salle a une destination active. Elle affiche la progression des jalons avec une barre d'achèvement, des puces de jalons individuels (cochées quand terminées) et des notes de parcours optionnelles.",
  "vscode.features.attentionSystem.heading": "Système d'attention",
  "vscode.features.attentionSystem.p1": "Quand les agents ont besoin de votre intervention, la barre latérale affiche une section \"Needs You\" en haut. Chaque élément d'attention affiche l'avatar de l'agent, la raison (détresse, bloqué, arrêté ou point de contrôle), un résumé de ce dont ils ont besoin, et un champ de réponse en ligne. Tapez une réponse et appuyez sur Entrée pour envoyer du contexte directement à cet agent. Vous pouvez également rejeter les éléments sur lesquels vous n'avez pas besoin d'agir.",
  "vscode.features.attentionSystem.p2": "Les éléments d'attention sont priorisés par urgence : les signaux de détresse (rouge, pulsant) viennent en premier, puis les agents bloqués (jaune), les sessions arrêtées (gris) et les points de contrôle (bleu). La barre d'état se met à jour pour montrer combien d'agents ont besoin de vous, et le badge de la barre latérale affiche le décompte. La détresse et les agents bloqués déclenchent également des popups d'avertissement natifs de VS Code.",
  "vscode.features.agentsPanel.heading": "Panneau d'agents",
  "vscode.features.agentsPanel.text": "Le panneau inférieur (à côté de vos onglets de terminal) affiche des cartes d'agents en direct dans une bande horizontale. Chaque carte affiche le nom de l'agent, point de statut, tâche actuelle, barre de progression, dernière action avec portée et balises de système. Les cartes sont triées avec les agents actifs en premier. Ce panneau vous donne un aperçu rapide de l'activité des agents pendant que vous travaillez dans le terminal.",
  "vscode.features.agentDecorations.heading": "Décorations d'agents",
  "vscode.features.agentDecorations.text": "Quand les agents enregistrent des opérations avec des métadonnées de portée référençant des fichiers que vous avez ouverts, l'extension affiche des décorations en ligne : points colorés dans la gouttière, annotations après le texte montrant le nom de l'agent, l'action, la portée et le temps écoulé, et des marques de règle de vue d'ensemble. Survolez une ligne décorée pour voir les détails complets incluant la portée de l'agent, le système et un lien pour ouvrir la barre latérale Eywa. Les décorations expirent automatiquement après 30 minutes.",
  "vscode.features.contextInjection.heading": "Injection de contexte",
  "vscode.features.contextInjection.text": "Envoyez des instructions ou du contexte à n'importe quel agent, ou diffusez à tous :",
  "vscode.features.contextInjection.item1": "<strong>Eywa: Inject Context</strong> - choisissez un agent cible, tapez un message, définissez la priorité",
  "vscode.features.contextInjection.item2": "<strong>Cmd+Shift+I</strong> (Mac) / <strong>Ctrl+Shift+I</strong> (Win/Linux) - sélectionnez du code dans l'éditeur et injectez-le avec le chemin du fichier et le contexte de plage de lignes",
  "vscode.features.contextInjection.item3": "<strong>Menu clic droit</strong> - quand vous avez du texte sélectionné, \"Eywa: Inject Selection to Agent\" apparaît dans le menu contextuel de l'éditeur",
  "vscode.features.contextInjection.priority": "Niveaux de priorité : <code>normal</code>, <code>high</code>, <code>urgent</code>. Les injections urgentes déclenchent un popup natif VS Code.",
  "vscode.features.terminalTabTitles.heading": "Titres d'onglets de terminal",
  "vscode.features.terminalTabTitles.text": "Activez <strong>Eywa: Toggle Agent Tab Titles</strong> pour afficher ce que fait Claude Code dans les noms de vos onglets de terminal (\"Editing auth.ts\", \"Running tests\", etc.). Utilise un hook PostToolUse avec un fichier flag à <code>~/.config/eywa/tab-title</code>, aucune variable d'environnement nécessaire.",
  "vscode.features.tagTerminals.heading": "Étiqueter les terminaux",
  "vscode.features.tagTerminals.text": "Utilisez <strong>Eywa: Tag Terminal with Agent</strong> pour associer le terminal actif à un agent spécifique. Choisissez dans la liste des agents connus ou entrez un nom personnalisé. Les terminaux étiquetés sont suivis pour que vous sachiez quel terminal appartient à quel agent.",
  "vscode.features.statusBar.heading": "Barre d'état",
  "vscode.features.statusBar.text": "Cliquez sur le statut Eywa en bas à gauche pour un menu de sélection rapide : changer de salle, voir les agents actifs, injecter du contexte, activer/désactiver les titres d'onglets, connecter des agents, se connecter ou ouvrir le tableau de bord. La barre d'état affiche le nom de la salle actuelle et se met à jour pour afficher le décompte d'attention quand les agents ont besoin de vous.",
  "vscode.commands.heading": "Commandes",
  "vscode.commands.col.command": "Commande",
  "vscode.commands.col.keybinding": "Raccourci clavier",
  "vscode.commands.col.description": "Description",
  "vscode.commands.login.desc": "Se connecter à Eywa via la connexion par navigateur",
  "vscode.commands.switchRoom.desc": "Changer la salle que vous surveillez",
  "vscode.commands.connectAgent.desc": "Obtenir une URL MCP pour un nouvel agent",
  "vscode.commands.injectContext.desc": "Envoyer du contexte/instructions à un agent",
  "vscode.commands.injectSelection.desc": "Injecter le code sélectionné à un agent",
  "vscode.commands.openDashboard.desc": "Ouvrir le tableau de bord web",
  "vscode.commands.refreshAgents.desc": "Actualiser manuellement la barre latérale",
  "vscode.commands.toggleTabTitles.desc": "Afficher les actions des agents dans les onglets de terminal",
  "vscode.commands.tagTerminal.desc": "Associer le terminal actif à un agent",
  "vscode.commands.showStatus.desc": "Menu de sélection rapide avec actions courantes",
  "vscode.settings.heading": "Paramètres",
  "vscode.settings.col.setting": "Paramètre",
  "vscode.settings.col.default": "Par défaut",
  "vscode.settings.col.description": "Description",
  "vscode.settings.supabaseUrl.default": "Instance hébergée",
  "vscode.settings.supabaseUrl.desc": "URL du projet Supabase",
  "vscode.settings.supabaseKey.default": "Instance hébergée",
  "vscode.settings.supabaseKey.desc": "Clé anonyme Supabase",
  "vscode.settings.room.default": "(vide)",
  "vscode.settings.room.desc": "Slug de la salle à surveiller",
  "vscode.settings.logLevel.desc": "Filtre du flux d'activité : <code>all</code>, <code>important</code> (sessions + connaissances + injections), ou <code>sessions</code> uniquement",
  "vscode.settings.historyHours.desc": "Combien d'heures d'historique charger (1, 6, 24 ou 72)",
  "vscode.settings.note": "L'URL et la clé Supabase sont par défaut l'instance Eywa hébergée. Vous n'avez besoin de les modifier que si vous auto-hébergez.",
  "vscode.links.heading": "Liens",
  "vscode.links.marketplace": "<a href=\"https://marketplace.visualstudio.com/items?itemName=curvilinear.eywa-agents\" target=\"_blank\" rel=\"noopener noreferrer\">Marketplace VS Code</a>",
  "vscode.links.dashboard": "<a href=\"https://eywa-ai.dev\" target=\"_blank\" rel=\"noopener noreferrer\">Tableau de bord web Eywa</a>",
  "vscode.links.github": "<a href=\"https://github.com/a-sumo/eywa\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a>",
  "spectacles.title": "Client AR Spectacles",
  "spectacles.lead": "Client AR Snap Spectacles pour Eywa. Affiche la mémoire des agents, le contexte et le chat sous forme de quads flottants dans l'espace mondial, diffusés depuis un renderer web via Supabase Realtime. Les Spectacles n'exécutent pas un navigateur complet. Au lieu de cela, une application web rend chaque élément d'interface utilisateur (cartes de mémoire, points d'agents, boutons, bulles de chat) comme de minuscules textures JPEG sur des OffscreenCanvases, les diffuse via Supabase Realtime, et les lunettes les décodent et les peignent sur des quads 3D.",
  "spectacles.streamingPipeline.heading": "Pipeline de diffusion",
  "spectacles.streamingPipeline.text": "Le tableau de bord web à <code>/r/&#123;room-slug&#125;/spectacles</code> sert de diffuseur. Il maintient un canal Supabase Realtime et diffuse l'activité de la salle, le chat Gemini et la progression de la destination vers les appareils Spectacles connectés.",
  "spectacles.streamingPipeline.dirty": "Chaque tuile est son propre quad avec son propre matériau cloné. Seules les tuiles sales se rendent à nouveau et rediffusent. La plupart des tuiles diffusent exactement une fois.",
  "spectacles.protocol.heading": "Protocole",
  "spectacles.protocol.channels.heading": "Canaux",
  "spectacles.protocol.channels.col.channel": "Canal",
  "spectacles.protocol.channels.col.purpose": "Objectif",
  "spectacles.protocol.channels.lobby": "Découverte d'appareils (battement de cœur, connexion, déconnexion)",
  "spectacles.protocol.channels.device": "Diffusion de tuiles (opérations de scène + textures)",
  "spectacles.protocol.channels.default": "Canal par défaut quand pas d'ID d'appareil",
  "spectacles.protocol.events.heading": "Événements",
  "spectacles.protocol.events.col.event": "Événement",
  "spectacles.protocol.events.col.direction": "Direction",
  "spectacles.protocol.events.col.payload": "Charge utile",
  "spectacles.protocol.events.scene.payload": "<code>&#123;op, id, x, y, w, h, ...&#125;</code> ou <code>&#123;ops: [...]&#125;</code>",
  "spectacles.protocol.events.tex.payload": "<code>&#123;id, image&#125;</code> (image est JPEG base64 brut)",
  "spectacles.protocol.events.interact.payload": "<code>&#123;id, type, x, y, u, v, timestamp&#125;</code> (type: tap, hover, hover_move, hover_exit)",
  "spectacles.protocol.events.camera.payload": "<code>&#123;x, y, z, wx, wy, wz, ts&#125;</code> (position locale + mondiale)",
  "spectacles.protocol.events.layout.payload": "<code>&#123;actions: [...], timestamp&#125;</code> (changements de mise en page par gestes)",
  "spectacles.protocol.events.syncRequest.payload": "<code>&#123;deviceId, timestamp&#125;</code> (demander une resynchronisation complète des tuiles)",
  "spectacles.protocol.events.deviceConnect.payload": "<code>&#123;deviceId, channelName, timestamp&#125;</code>",
  "spectacles.protocol.events.deviceHeartbeat.payload": "<code>&#123;deviceId, channelName, timestamp&#125;</code>",
  "spectacles.protocol.events.voiceInput.payload": "<code>&#123;text, timestamp&#125;</code> (transcription de la parole de l'utilisateur)",
  "spectacles.protocol.events.voiceResponse.payload": "<code>&#123;text, timestamp&#125;</code> (transcription de la réponse Gemini)",
  "spectacles.protocol.events.voiceInject.payload": "<code>&#123;message, priority, timestamp&#125;</code> (injecté dans la salle)",
  "spectacles.protocol.sceneOps.heading": "Opérations de scène",
  "spectacles.protocol.sceneOps.create": "<code>create</code> - nouveau quad : <code>&#123;op:\"create\", id, x, y, z, w, h, layer, group, interactive, s&#125;</code>",
  "spectacles.protocol.sceneOps.destroy": "<code>destroy</code> - supprimer quad : <code>&#123;op:\"destroy\", id&#125;</code>",
  "spectacles.protocol.sceneOps.visibility": "<code>visibility</code> - afficher/cacher : <code>&#123;op:\"visibility\", id, visible&#125;</code>",
  "spectacles.protocol.sceneOps.group": "<code>group</code> - créer/positionner un conteneur de groupe : <code>&#123;op:\"group\", id, x, y, z, visible&#125;</code>",
  "spectacles.protocol.sceneOps.groupDestroy": "<code>group-destroy</code> - supprimer un groupe et tous ses enfants : <code>&#123;op:\"group-destroy\", id&#125;</code>",
  "spectacles.protocol.sceneOps.move": "<code>move</code> / <code>group-move</code> - actuellement ignoré (mise en page statique après création)",
  "spectacles.setup.heading": "Configuration",
  "spectacles.setup.lensStudio.heading": "1. Projet Lens Studio",
  "spectacles.setup.lensStudio.text": "Ouvrez <code>eywa-specs.esproj</code> dans Lens Studio.",
  "spectacles.setup.supabasePlugin.heading": "2. Plugin Supabase",
  "spectacles.setup.supabasePlugin.text": "Window > Supabase > Login > Import Credentials. Cela crée un actif SupabaseProject.",
  "spectacles.setup.sceneHierarchy.heading": "3. Hiérarchie de scène",
  "spectacles.setup.webBroadcaster.heading": "4. Diffuseur web",
  "spectacles.setup.webBroadcaster.text": "Naviguez vers <code>/r/&#123;room-slug&#125;/spectacles</code> dans l'application web Eywa. Cliquez sur \"Start Broadcast\". La page rend les tuiles et les diffuse vers tout appareil Spectacles connecté.",
  "spectacles.setup.testInEditor.heading": "5. Test dans l'éditeur",
  "spectacles.setup.testInEditor.text": "Poussez vers l'appareil ou utilisez l'aperçu Lens Studio. Vérifiez le panneau Logger pour les événements de connexion et de tuiles :",
  "spectacles.voiceInterface.heading": "Interface vocale (EywaGeminiLive)",
  "spectacles.voiceInterface.text": "Les Spectacles ont une interface vocale bidirectionnelle alimentée par Gemini Live. L'utilisateur parle, Gemini répond avec de l'audio, et les transcriptions relaient vers le tableau de bord web en temps réel. Gemini peut également injecter des messages dans la salle, permettant aux utilisateurs de piloter l'essaim d'agents par la voix.",
  "spectacles.voiceInterface.howItWorks.heading": "Comment ça fonctionne",
  "spectacles.voiceInterface.howItWorks.step1": "À l'initialisation, <code>EywaGeminiLive.ts</code> récupère les mémoires récentes et la destination depuis Supabase",
  "spectacles.voiceInterface.howItWorks.step2": "Ce contexte devient les instructions système de Gemini (\"Vous êtes Eywa, un assistant vocal pour naviguer dans un essaim d'agents\")",
  "spectacles.voiceInterface.howItWorks.step3": "L'audio du micro diffuse vers Gemini Live via le proxy WebSocket de Snap (pas de clé API nécessaire)",
  "spectacles.voiceInterface.howItWorks.step4": "Gemini répond avec de l'audio (joué sur les lunettes) et une transcription texte",
  "spectacles.voiceInterface.howItWorks.step5": "Les transcriptions relaient vers le web via le canal de diffusion (événements <code>voice_input</code>, <code>voice_response</code>, <code>voice_inject</code>)",
  "spectacles.voiceInterface.howItWorks.step6": "Gemini a un outil <code>inject_message</code> qui écrit directement dans la table mémoires Supabase, rendant le message visible à tous les agents de la salle",
  "spectacles.voiceInterface.broadcastEvents.heading": "Événements de diffusion",
  "spectacles.voiceInterface.broadcastEvents.col.event": "Événement",
  "spectacles.voiceInterface.broadcastEvents.col.direction": "Direction",
  "spectacles.voiceInterface.broadcastEvents.col.payload": "Charge utile",
  "spectacles.voiceInterface.broadcastEvents.col.description": "Description",
  "spectacles.voiceInterface.broadcastEvents.voiceInput.desc": "Transcription de la parole de l'utilisateur",
  "spectacles.voiceInterface.broadcastEvents.voiceResponse.desc": "Transcription de la réponse Gemini",
  "spectacles.voiceInterface.broadcastEvents.voiceInject.desc": "Message injecté dans la salle",
  "spectacles.voiceInterface.testingWithout.heading": "Test sans Spectacles",
  "spectacles.voiceInterface.testingWithout.text": "Exécutez l'application web et ouvrez la page de diffusion Spectacles. Puis simulez des événements vocaux depuis la console du navigateur :",
  "spectacles.markerTracking.heading": "Suivi de marqueur (optionnel)",
  "spectacles.markerTracking.text": "La scène utilise le Extended Marker Tracking pour ancrer optionnellement le panneau AR à un écran physique. Un marqueur n'est pas requis. Le panneau apparaît à une position par défaut automatiquement.",
  "spectacles.markerTracking.defaultMode.heading": "Mode par défaut (sans marqueur)",
  "spectacles.markerTracking.defaultMode.step1": "Au lancement, une garde de préchauffage de 2 secondes ignore les détections de faux positifs des premières images",
  "spectacles.markerTracking.defaultMode.step2": "Après 3 secondes sans marqueur détecté, le panneau se détache automatiquement à une position par défaut : 65 cm vers l'avant, 3 cm sous le niveau des yeux",
  "spectacles.markerTracking.defaultMode.step3": "Si un marqueur est détecté plus tard, le panneau se repositionne à l'emplacement du marqueur",
  "spectacles.markerTracking.defaultMode.step4": "L'IMU des Spectacles gère le suivi d'orientation après placement",
  "spectacles.markerTracking.markerMode.heading": "Mode marqueur",
  "spectacles.markerTracking.markerMode.step1": "La caméra des Spectacles détecte le motif du marqueur de suivi sur un écran physique",
  "spectacles.markerTracking.markerMode.step2": "Le panneau AR apparaît à la position du marqueur (les enfants commencent désactivés, activés lors de la détection)",
  "spectacles.markerTracking.markerMode.step3": "Avec <code>trackMarkerOnce: true</code>, le marqueur est détecté une fois, le panneau se détache dans l'espace mondial, et le suivi du marqueur est désactivé pour économiser les performances",
  "spectacles.markerTracking.sceneHierarchy.heading": "Hiérarchie de scène",
  "spectacles.troubleshooting.heading": "Dépannage",
  "spectacles.troubleshooting.snapCloud.heading": "\"SnapCloudRequirements not configured\"",
  "spectacles.troubleshooting.snapCloud.text": "Assignez l'actif SupabaseProject dans l'Inspector.",
  "spectacles.troubleshooting.noEvents.heading": "Le canal s'abonne mais aucun événement n'arrive",
  "spectacles.troubleshooting.noEvents.item1": "Vérifiez que les noms de canaux correspondent : le web envoie sur <code>spectacles:&#123;slug&#125;:&#123;deviceId&#125;</code>, les Spectacles s'abonnent au même",
  "spectacles.troubleshooting.noEvents.item2": "Ouvrez la console du navigateur côté web et vérifiez le statut \"SUBSCRIBED\"",
  "spectacles.troubleshooting.noEvents.item3": "Le deviceId par défaut est \"editor\" des deux côtés",
  "spectacles.troubleshooting.noTiles.heading": "Les quads de test apparaissent mais pas les tuiles diffusées",
  "spectacles.troubleshooting.noTiles.item1": "Activez <code>showTestQuads</code> dans l'Inspector pour vérifier le pipeline mesh/matériau",
  "spectacles.troubleshooting.noTiles.item2": "Vérifiez le Logger pour les messages \"scene event\" ou \"tex event\"",
  "spectacles.troubleshooting.noTiles.item3": "Si aucun événement, l'abonnement au canal pourrait échouer. Vérifiez les erreurs d'authentification ou réseau",
  "spectacles.troubleshooting.texturesDecode.heading": "Les textures échouent à décoder",
  "spectacles.troubleshooting.texturesDecode.item1": "La chaîne Base64 pourrait être trop grande. Vérifiez les paramètres de qualité JPEG dans tileRenderers.ts",
  "spectacles.troubleshooting.texturesDecode.item2": "Supabase Realtime a une limite de message d'environ 1 Mo. Les textures de tuiles individuelles font généralement 5-15 Ko",
  "spectacles.troubleshooting.wrongSize.heading": "Quads visibles mais mauvaise taille ou position",
  "spectacles.troubleshooting.wrongSize.item1": "<code>pixelsPerCm</code> contrôle l'échelle : largeur_cm = largeur_pixels / pixelsPerCm",
  "spectacles.troubleshooting.wrongSize.item2": "Les positions sont en cm, centrées à l'origine du panneau",
  "spectacles.troubleshooting.wrongSize.item3": "Décalages Z de couche : 0=0.05cm, 1=1.5cm, 2=2.5cm, 3=3.5cm",
  "spectacles.ergonomics.heading": "Ergonomie",
  "spectacles.ergonomics.col.parameter": "Paramètre",
  "spectacles.ergonomics.col.value": "Valeur",
  "spectacles.ergonomics.comfortDistance": "Distance de confort",
  "spectacles.ergonomics.comfortRectangle": "Rectangle de confort",
  "spectacles.ergonomics.defaultTile": "Tuile par défaut",
  "spectacles.ergonomics.bodyTextMin": "Texte de corps minimum",
  "spectacles.ergonomics.tapTargetMin": "Cible de tap minimum",
  "spectacles.dependencies.heading": "Dépendances",
  "spectacles.dependencies.lensStudio": "Lens Studio (dernière version)",
  "spectacles.dependencies.interactionKit": "SpectaclesInteractionKit.lspkg (suivi des mains, pincement, Interactable)",
  "spectacles.dependencies.supabaseClient": "SupabaseClient.lspkg (SDK Supabase de Snap pour Lens Studio)",
  "spectacles.dependencies.supabaseProject": "Projet Supabase avec Realtime activé",
  "selfHosting.title": "Auto-hébergement",
  "selfHosting.lead": "Eywa est entièrement open source. Vous pouvez exécuter votre propre instance avec Supabase pour la base de données, un Cloudflare Worker pour le serveur MCP et Vite pour le tableau de bord.",
  "selfHosting.database.heading": "1. Base de données (Supabase)",
  "selfHosting.database.intro": "Supabase fournit PostgreSQL avec des abonnements Realtime intégrés. Le tableau de bord et toutes les intégrations dépendent de Realtime pour les mises à jour en direct.",
  "selfHosting.database.step1": "Créez un projet sur <a href=\"https://supabase.com\" target=\"_blank\" rel=\"noopener noreferrer\">supabase.com</a>",
  "selfHosting.database.step2": "Ouvrez l'éditeur SQL et exécutez le contenu de <code>schema.sql</code>",
  "selfHosting.database.step3": "Activez Realtime pour les tables <code>memories</code> et <code>messages</code>. Allez dans Database &gt; Replication, puis activez Realtime pour les deux tables.",
  "selfHosting.database.step4": "Copiez votre URL de projet et votre clé de rôle de service depuis Settings &gt; API. Vous aurez besoin des deux pour le worker et le tableau de bord.",
  "selfHosting.schema.heading": "Aperçu du schéma",
  "selfHosting.schema.description": "Le schéma définit cinq tables : <code>rooms</code> (espaces de travail), <code>memories</code> (toute l'activité des agents), <code>messages</code> (chat d'équipe), <code>links</code> (connexions inter-sessions) et <code>global_insights</code> (connaissances réseau anonymisées). La table <code>memories</code> est le cœur d'Eywa. Tout ce que les agents enregistrent, des événements de session aux entrées de connaissances en passant par les mises à jour de destination, va ici avec une colonne <code>metadata</code> JSONB pour les balises structurées.",
  "selfHosting.worker.heading": "2. Serveur MCP (Cloudflare Worker)",
  "selfHosting.worker.intro": "Le serveur MCP est un Cloudflare Worker sans état qui traduit les appels d'outils MCP en requêtes Supabase PostgREST. Il utilise des appels fetch HTTP bruts, pas le SDK JS Supabase.",
  "selfHosting.worker.endpointNote": "Après le déploiement, votre point de terminaison MCP sera disponible à l'URL imprimée par wrangler. Les agents se connectent à <code>https://your-worker.workers.dev/mcp?room=mon-equipe&amp;agent=claude/alice</code>.",
  "selfHosting.worker.localDev.heading": "Développement local",
  "selfHosting.worker.localDev.description": "Pour les tests locaux, utilisez <code>npx wrangler dev</code> au lieu de deploy. Le worker démarrera sur <code>http://localhost:8787</code>. Définissez les variables d'environnement dans <code>wrangler.toml</code> sous <code>[vars]</code> pour le développement local, ou utilisez <code>.dev.vars</code> pour les secrets.",
  "selfHosting.dashboard.heading": "3. Tableau de bord (React/Vite)",
  "selfHosting.dashboard.intro": "Le tableau de bord web est une application React 19 construite avec Vite. Il se connecte directement à Supabase en utilisant le SDK JS et s'abonne aux canaux Realtime pour les mises à jour en direct.",
  "selfHosting.dashboard.envInstruction": "Modifiez <code>.env</code> avec vos identifiants Supabase et votre clé API Gemini :",
  "selfHosting.dashboard.installAndRun": "Puis installez et exécutez :",
  "selfHosting.dashboard.geminiNote": "La clé API Gemini est optionnelle. Sans elle, le panneau de pilotage Gemini dans le tableau de bord sera désactivé, mais tout le reste fonctionne normalement.",
  "selfHosting.discord.heading": "4. Bot Discord (optionnel)",
  "selfHosting.discord.intro": "Le bot Discord fournit 15 commandes slash pour l'observabilité de l'équipe depuis le chat. Il se connecte directement à Supabase, pas via le serveur MCP.",
  "selfHosting.discord.envInstruction": "Modifiez <code>.env</code> avec votre token de bot Discord et vos identifiants Supabase :",
  "selfHosting.discord.installAndStart": "Puis installez, déployez les commandes et démarrez :",
  "selfHosting.discord.commands.heading": "Commandes disponibles",
  "selfHosting.discord.commands.help": "<code>/help</code> - Afficher toutes les commandes",
  "selfHosting.discord.commands.room": "<code>/room</code> - Voir ou définir la salle actuelle",
  "selfHosting.discord.commands.status": "<code>/status</code> - Vue d'ensemble du statut des agents",
  "selfHosting.discord.commands.agents": "<code>/agents</code> - Lister tous les agents de la salle",
  "selfHosting.discord.commands.context": "<code>/context</code> - Contexte partagé récent",
  "selfHosting.discord.commands.search": "<code>/search</code> - Rechercher dans les mémoires des agents",
  "selfHosting.discord.commands.recall": "<code>/recall</code> - Rappeler les messages d'un agent spécifique",
  "selfHosting.discord.commands.inject": "<code>/inject</code> - Pousser du contexte vers un agent",
  "selfHosting.discord.commands.inbox": "<code>/inbox</code> - Vérifier les injections en attente",
  "selfHosting.discord.commands.knowledge": "<code>/knowledge</code> - Parcourir la base de connaissances",
  "selfHosting.discord.commands.learn": "<code>/learn</code> - Stocker de nouvelles connaissances",
  "selfHosting.discord.commands.msg": "<code>/msg</code> - Envoyer un message à la salle",
  "selfHosting.discord.commands.destination": "<code>/destination</code> - Voir ou définir la destination de l'équipe",
  "selfHosting.discord.commands.course": "<code>/course</code> - Vérifier la progression vers la destination",
  "selfHosting.discord.commands.network": "<code>/network</code> - Interroger le réseau mondial d'insights",
  "selfHosting.vscode.heading": "5. Extension VS Code (optionnel)",
  "selfHosting.vscode.description": "L'extension VS Code affiche une barre latérale d'arborescence d'agents, un flux d'activité, une injection de contexte et une lentille de connaissances. Voir <code>vscode-extension/</code> pour les instructions de construction.",
  "selfHosting.updateMcpUrl.heading": "Mise à jour de l'URL MCP",
  "selfHosting.updateMcpUrl.description": "Après avoir déployé votre propre worker, mettez à jour l'URL MCP dans vos configurations d'agents pour pointer vers votre worker au lieu de la version hébergée. Remplacez <code>mcp.eywa-ai.dev</code> par l'URL de votre worker :",
  "pi.title": "Écrans Pi",
  "pi.lead": "Scripts Raspberry Pi pour écrans physiques Eywa. Deux options matérielles servent des rôles différents : l'écran e-ink agit comme un tableau de statut ambiant et une ancre de suivi AR, tandis que l'écran tactile TFT fournit une interaction directe avec les agents. Si vous n'avez pas de Pi, tout appareil avec un navigateur fonctionne comme solution de repli.",
  "pi.hardware.heading": "Matériel",
  "pi.hardware.table.display": "Écran",
  "pi.hardware.table.resolution": "Résolution",
  "pi.hardware.table.type": "Type",
  "pi.hardware.table.script": "Script",
  "pi.hardware.table.waveshare.name": "Waveshare 5.65\" ACeP 7 couleurs",
  "pi.hardware.table.waveshare.type": "E-Ink (passif)",
  "pi.hardware.table.tft.name": "TFT ILI9341 3.5\"",
  "pi.hardware.table.tft.type": "LCD (tactile)",
  "pi.displayStrategy.heading": "Stratégie d'écran",
  "pi.displayStrategy.eink.heading": "E-ink (surface mate) - ancre AR + statut ambiant",
  "pi.displayStrategy.eink.matteTracking": "L'e-ink mat a zéro réflexion, le rendant fiable pour le suivi d'image Spectacles",
  "pi.displayStrategy.eink.fixedMarker": "Un marqueur de suivi fixe dans le côté droit de l'écran ancre l'interface AR à l'écran physique",
  "pi.displayStrategy.eink.noTouch": "Pas d'entrée tactile. Les Spectacles fournissent l'interaction via le suivi des mains et les gestes de pincement",
  "pi.displayStrategy.eink.refresh": "Se rafraîchit toutes les 5 minutes par défaut (configurable via <code>--interval</code>) avec le statut des agents, les infos de salle et le marqueur de suivi",
  "pi.displayStrategy.eink.lowPower": "Faible consommation. Fonctionne pendant des heures sur une batterie externe.",
  "pi.displayStrategy.tft.heading": "Tactile TFT (LCD brillant) - surface de contrôle interactive",
  "pi.displayStrategy.tft.noTracking": "Pas de marqueur de suivi. Les écrans brillants causent des réflexions qui cassent le suivi d'image",
  "pi.displayStrategy.tft.directTouch": "Interaction tactile directe : toucher les agents, envoyer des injections, parcourir les mémoires",
  "pi.displayStrategy.tft.refreshRate": "Taux de rafraîchissement plus élevé (30fps) pour une interface réactive",
  "pi.displayStrategy.tft.useCase": "Utilisé quand vous voulez interagir avec les agents sans Spectacles",
  "pi.wiring.heading": "Câblage",
  "pi.wiring.eink.heading": "E-Ink (HAT Waveshare)",
  "pi.wiring.eink.description": "Il suffit de brancher le HAT sur l'en-tête GPIO du Pi. Aucun câblage supplémentaire nécessaire. Pour les modules autonomes (sans HAT), utilisez le diagramme interactif ci-dessous pour voir quelles broches connecter.",
  "pi.wiring.eink.moduleHeading": "Câblage du module Waveshare",
  "pi.wiring.eink.moduleHint": "Sélectionnez un type d'appareil pour voir ses connexions GPIO. Survolez n'importe quelle broche pour tracer le fil.",
  "pi.wiring.tft.heading": "TFT (ILI9341 3.5\" + tactile XPT2046)",
  "pi.wiring.tft.description": "L'écran ILI9341 et le contrôleur tactile XPT2046 partagent le bus SPI. Activez/désactivez les couches LCD et tactile indépendamment pour voir quelles broches sont partagées.",
  "pi.einkSetup.heading": "Configuration E-Ink (Waveshare 5.65\" ACeP)",
  "pi.einkSetup.step1.heading": "1. Activer SPI sur Pi",
  "pi.einkSetup.step2.heading": "2. Installer la bibliothèque Waveshare",
  "pi.einkSetup.step3.heading": "3. Installer les dépendances Python",
  "pi.einkSetup.step4.heading": "4. Définir l'environnement",
  "pi.einkSetup.step5.heading": "5. Exécuter",
  "pi.einkSetup.step6.heading": "6. Démarrage automatique au boot (systemd)",
  "pi.tftSetup.heading": "Configuration tactile TFT (ILI9341 3.5\")",
  "pi.tftSetup.step1.heading": "1. Activer SPI + installer fbcp",
  "pi.tftSetup.step2.heading": "2. Exécuter l'interface tactile",
  "pi.fallback.heading": "Mini écran de repli (Téléphone/Tablette/Web)",
  "pi.fallback.intro": "Si vous n'avez pas de Raspberry Pi, vous pouvez utiliser n'importe quel appareil avec un navigateur comme écran. Le tableau de bord web inclut des vues optimisées pour l'affichage.",
  "pi.fallback.eink.heading": "MiniEywaEink (mode ambiant)",
  "pi.fallback.eink.description": "Naviguez vers <code>/r/&#123;room-slug&#125;</code> et sélectionnez la vue e-ink. Rend une mise en page statique avec le nom de la salle, les avatars et statuts des agents, le flux d'activité et un QR code de salle. Utile pour un téléphone posé sur un bureau, une vieille tablette montée sur un mur, ou un Raspberry Pi exécutant Chromium en mode kiosque.",
  "pi.fallback.spectacles.heading": "SpectaclesView (diffusion AR)",
  "pi.fallback.spectacles.description": "Naviguez vers <code>/r/&#123;room-slug&#125;/spectacles</code> et cliquez sur \"Broadcast\". Cela rend les textures de tuiles et les diffuse vers les Spectacles connectés via Supabase Realtime.",
  "pi.testScripts.heading": "Scripts de test",
  "pi.testScripts.intro": "Exécutez-les après le câblage pour vérifier le matériel avant d'utiliser les applications Eywa complètes.",
  "pi.testScripts.table.script": "Script",
  "pi.testScripts.table.whatItTests": "Ce qu'il teste",
  "pi.testScripts.table.displayNeeded": "Écran nécessaire ?",
  "pi.testScripts.table.tft.tests": "Barres de couleurs TFT, rendu de texte, entrée tactile",
  "pi.testScripts.table.tft.display": "TFT (ou <code>--window</code> pour laptop)",
  "pi.testScripts.table.eink.tests": "Échantillons e-ink 7 couleurs, formes, grille de pixels",
  "pi.testScripts.table.eink.display": "E-ink (ou <code>--preview</code> pour PNG, <code>--clear</code> pour effacer l'écran)",
  "pi.testScripts.table.touch.tests": "Événements tactiles bruts, plages de coordonnées, détection d'appareil",
  "pi.testScripts.table.touch.display": "Aucun (lit l'entrée du noyau)"
}
